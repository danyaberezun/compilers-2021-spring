-- States: partial maps from variables into values

import Collection;
import List;
import Lexer;
import Parser;

-- State with a stack of scopes; each scope is a map from names to
-- their kind and values
fun makeFullState ([scopes, outers, global]) {
  fun makeState (s) {
    makeFullState ([s, outers, global])
  }

  -- Searches a scope stack and performed a specified action
  -- on the found binding
  fun lookup (name, action) {
    fun lookupInScopes (scopes) {
      case scopes of
        {}         -> case findMap (global, name) of
                        None     -> error (sprintf ("name ""%s"" undefined", name), getLoc (name))
                      | Some (x) -> x
                      esac
      | s : scopes ->
         case findMap (s, name) of
           None     -> lookupInScopes (scopes)
         | Some (x) -> x
         esac
      esac
    }

    lookupInScopes (scopes)  
  }
  
  -- Makes and assignment in scopes
  fun assign (name, vl) {
    fun assignInScopes (scopes) {
      case scopes of
        {}         -> case findMap (global, name) of
                        None -> error (sprintf ("name ""%s"" undefined", name), getLoc (name))
                      | Some (_) -> [{}, outers, addMap (global, name, vl)]
                      esac
      | s : scopes ->
         case findMap (s, name) of
           None     -> case assignInScopes (scopes) of [ss, o, g] -> [s : ss, o, g] esac
         | Some (_) -> [addMap (s, name, vl) : scopes, outers, global]
         esac
      esac    
    }

    makeFullState (assignInScopes (scopes))
  }

  -- Enters a new scope
  fun enterScope () {    
    case global of 
      Void -> makeFullState ([{}, outers, emptyMap (compare)])
    | _    -> makeState (emptyMap (compare) : scopes)
    esac
  }

  -- Leaves a scope
  fun leaveScope () {
    case scopes of
      scope:scopes -> makeState (scopes)
    | _            -> makeFullState ([{}, outers, Void])
    esac
  }

  -- Adds a name into a scope
  fun addName (name, vl) {
    case scopes of
      s : scopes ->
       case findMap (s, name) of
         None     -> makeState (addMap (s, name, vl) : scopes)
       | Some (_) -> error (sprintf ("duplicate ""%s"" name definition", name), getLoc (name))
       esac
    | _ ->  case findMap (global, name) of
              None     -> makeFullState ([scopes, outers, addMap (global, name, vl)])
            | Some (_) -> error (sprintf ("duplicate ""%s"" name definition", name), getLoc (name))
            esac
    esac
  }

  -- Enters a function; this drops all local scopes and creates a new one
  fun enterFunction () {
    makeFullState ([{emptyMap (compare)}, scopes : outers, global])
  }

  -- Leaves a function: replaces the global scope in the state with a given one
  fun leaveFunction () {
    case outers of outer : outers ->
      makeFullState ([outer, outers, global])
    esac
  }
  
  [lookup, assign, enterScope, leaveScope, addName, enterFunction, leaveFunction]
}

-- Accessors functions
public fun lookup (state, x) {
  state [0] (x)
}

public infix <- before : (state, [x, v]) {
  state [1] (x, v)
}

public fun enterScope (state) {
  state [2] ()
}

public fun leaveScope (state) {
  state [3] ()
}

public fun addName (state, name, vl) {
  state [4] (name, vl)
}

public fun enterFunction (state) {
  state [5] ()
}

public fun leaveFunction (state) {
  state [6] ()
}

-- Creates an empty state
public fun emptyState () {
  makeFullState ([{}, {}, Void])
}
