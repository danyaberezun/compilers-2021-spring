-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

infix ## after | (a, b) { Seq (a, b) } 

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, vl, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (vl)
  | _    -> vl
  esac
}

-- Checks if a void epxression can be used in the context described by
-- the attribute "atr".
fun assertVoid (atr, vl, loc) {
  case atr of
    Void -> vl
  | Val  -> error ("value expected", loc)
  | Weak -> Seq (vl, Const (0))
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Ignore (Assn (Ref (ident), value)) ## expr]
             esac
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Var (ds) ->             
                 case expandDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

fun distributeAtr (atr, xs) {
  map (fun (x) {x (atr)}, xs)
}

fun orSkip (op, a) {
  case op of
    None -> assertVoid (a, Skip, loc)
  | Some (x) -> x (a)
  esac
}

var ifStmt = memo $ eta syntax (
  loc=pos  -kIf e=exp -kThen s=scopeExpr rest=elsePart? -kFi 
  { fun (a) {If (e (Val), s (a), orSkip (rest, a, loc))} }
);

var elsePart = memo $ eta syntax (
  loc=pos -kElif e=exp -kThen s=scopeExpr rest=elsePart? 
  { fun (a) {If (e (Val), s (a), orSkip (rest, a, loc))} }
  | -kElse scopeExpr
);

var loopStmt = memo $ eta syntax (
    loc=pos -kWhile cond=exp -kDo body=scopeExpr -kOd 
    { fun (a)   { assertVoid (a, While (cond (Val), body (Void)), loc) } }
  | loc=pos -kDo body=scopeExpr -kWhile cond=exp -kOd
  -- make top-level definitions of body visible in condition
    { case body (Void) of Scope (defs, body) -> 
        fun (a) { assertVoid (a, Scope (defs, DoWhile (body, cond (Val))), loc) }
      esac }
  | loc=pos -kFor init=scopeExpr -s[","] cond=exp -s[","] inc=exp -kDo body=scopeExpr -kOd 
  -- make top-level definitions of init visible in the rest
    { case init (Void) of Scope (defs, init) -> 
        fun (a) { assertVoid (a, Scope (defs, init ## While (cond (Val), body (Void) ## inc (Void))), loc) } 
      esac }
);

var primary  = memo $ eta syntax (
  -- N
    loc=pos x=decimal { fun (a) {assertValue (a, Const (stringInt (x)), loc)} }
  -- str
  | loc=pos s=strlit  { fun (a) {assertValue (a, String (s), loc)}}
  -- char
  | loc=pos ch=chrlit { fun (a) {assertValue (a, Const (ch), loc)}}
  -- identifier
  | x=lident { fun (a) {
      case a of
        Ref  -> Ref (x)
      | Void -> Ignore (Var (x))
      | _    -> Var (x)
      esac}}
  -- skip
  | loc=pos -kSkip { fun (a) {assertVoid (a, Skip, loc)}}
  -- control flow
  | ifStmt
  | loopStmt
  -- ( exp )
  | -s["("] se=scopeExpr -s[")"] { fun (a) {se (a)} }
  -- call (...)
  | loc=pos name=lident -s["("] args=list0[exp] -s[")"]  
    { fun (a) {assertValue (a, Call (name, distributeAtr (Val, args)), loc)} }
  -- [e, e,..., e]
  | loc=pos -s["["] elems=list0[exp] -s["]"] 
    { fun (a) {assertValue (a, Array (distributeAtr (Val, elems)), loc)}}
  -- a[i]
  | loc=pos arr=primary -s["["] ix=basicExp -s["]"]
    { fun (a) { case a of 
        Ref ->              ElemRef (arr (Val), ix (Val))
      | _   -> assertValue (a, Elem (arr (Val), ix (Val)), loc) esac }}
  );


var basicExp = memo $ eta (expr ({
  [Right, {[s (":="), fun (l, loc, r) { 
                        fun (a) {assertValue (a, Assn (l (Ref), r (Val)), loc)} }]}],
  [Left , map (binop, {"!!"})],
  [Left , map (binop, {"&&"})],
  [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
  [Left , map (binop, {"+", "-"})],
  [Left , map (binop, {"*", "/", "%"})]},
  primary));
      
var exp = memo $ eta syntax (
    basicExp -s[";"]?
  | s1=basicExp -s[";"] s2=exp { fun (a) {s1 (Void) ## s2 (a)}}
);

var varDef = memo $ eta syntax (
    name=lident -s["="] e=basicExp { [name, Some (e (Val))] }
  | name=lident                    { [name, None] }
);

var def = memo $ eta syntax (
    -kVar ds=list[varDef] -s[";"]   { Var (ds) }
  | -kFun name=lident -s["("] args=list0[lident] -s[")"]
    -s["{"] body=scopeExpr -s["}"]  { Fun (name, args, body (Weak)) }
); 

var scopeExpr = memo $ eta syntax (
  loc=pos defs=def* e=exp? { fun (a) {expandScope (defs, orSkip (e, a, loc))} }
);

-- Public top-level parser
public parse = syntax (e=scopeExpr {e (Void)});
-- DEBUG! public parse = syntax (e=scopeExpr {var x = e (Void); Skip});
