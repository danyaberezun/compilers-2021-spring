-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop(op) {
  [s (op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr ({[Left, {binop ("!!")}],
                               [Left, {binop ("&&")}],
                               [Nona, map (binop, {"<", ">", "<=", ">=", "==", "!="})],
                               [Left, map (binop, {"+", "-"})],
                               [Left, map (binop, {"*", "/", "%"})]}, primary));

var statement = memo $ eta syntax (
    variable=lident s[":="] expression=exp           {Assn (variable, expression)} |
    kSkip                                            {Skip}                        |
    kRead variable=inbr[s ("("), lident, s (")")]    {Read (variable)}             |
    kWrite expression=inbr[s ("("), exp, s (")")]    {Write (expression)}          |
    kIf condition=exp kThen trueBranch=statements falseBranch=elseStatement 
                                                     {If (condition, trueBranch, falseBranch)} |
    kWhile condition=exp kDo body=statements kOd     {While (condition, body)}     |
    kDo body=statements kWhile condition=exp kOd     {DoWhile (body, condition)}   |
    kFor initializer=statement s[","] condition=exp s[","]
      increment=statement kDo body=statements kOd    {Seq (initializer, 
                                                        While (condition, 
                                                        Seq (body, increment)))}
  ),
  statements = memo $ eta syntax (
    statement | first=statement s[";"] second=statements {Seq (first, second)}
  ),
  elseStatement = memo $ eta syntax (
    kFi                          {Skip}   |
    kElse branch=statements kFi  {branch} |
    kElif condition=exp kThen trueBranch=statements 
      falseBranch=elseStatement  {If (condition, trueBranch, falseBranch)}
  );

-- Public top-level parser
public parse = statements;
