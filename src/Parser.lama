-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;
import STM;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- AST environment
fun createEnv (id) {
  fun freshName () {
    [createEnv (id+1), sprintf ("_tmp%d", id)]
  }

  [freshName]
}

fun emptyEnv () {
  createEnv (0)
}

fun freshName (env) {
  env [0] ()
}

-- Attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, vl, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> vl => fun (vl) {Ignore (vl)}
  | _    -> vl
  esac
}

-- Checks if a void epxression can be used in the context described by
-- the attribute "atr".
fun assertVoid (atr, vl, loc) {
  case atr of
    Void -> vl
  | Val  -> error ("value expected", loc)
  | Weak -> vl => fun (vl) {Seq (vl, Const (0))}
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inRoundBrackets(p) {
  inbr(s ("("), p, s (")"))
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, l (Val) =>> fun (l) {
                                            r (Val) =>  fun (r) {
                                              Binop (op, l, r)
                                            }}, loc)
                          }
                        }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Assn (Ref (ident), value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Var (ds)      ->
                 case expandDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

-- Helper AST function: reifies pattern bindings into scope
-- definitions and assignments; takes an returns lists of
-- pattern-branch pairs
fun reifyPatternBindings (matched, brs) {
  map (
    fun ([pat, br]) {      
      fun collectBindings (path, p) {
        fun collectList (path, ps) {
          case
            foldl (fun ([acc, i], p) {
                     [collectBindings (i : path, p) : acc, i+1]                      
                   },
                   [{}, 0],
                   ps) of
            [acc, _] -> flatten (acc)
          esac            
        }
        
        case p of
          Sexp  (_, ps)   -> collectList (path, ps)
        | Array (ps)      -> collectList (path, ps)
        | Named (name, Some (p)) -> [name, path] : collectBindings (path, p)
        | Named (name, None) -> {[name, path]}
        |  _              -> {}
        esac
      }

      case collectBindings ({}, pat) of
        {}       -> [pat, br]
      | bindings ->
           [pat,
             expandScope (
               {Var (map (
                      fun ([name, path]) {
                        var value = foldr (fun (p, i) {Elem (p, Const (i))}, Var (matched), path); 
                        [name, Some (value)]
                      },
                      bindings))},
               br
             )]
      esac
    },
    brs
  )
}

var binopParsers = {
  [Right, {[s (":="), fun (l, loc, r) {
                        fun (atr) {
                          assertValue (atr, l (Ref) =>> fun (tL) {
                                            r (Val) => fun (tR) {
                                              Assn (tL, tR)
                                            }}, loc)
                        }
                      }]}],
  [Left , map (binop, {"!!"})],
  [Left , map (binop, {"&&"})],
  [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
  [Left , map (binop, {"+", "-"})],
  [Left , map (binop, {"*", "/", "%"})]
};

var primary = memo $ eta syntax (
  loc=pos x=inbr[s("["), list0(argParser), s("]")] {
    fun (atr) {
      assertValue (atr, chainST (x) => fun (t) {Array (t)}, loc)
    }
  } |
  loc=pos x=strlit {
    fun (atr) {
      assertValue (atr, returnST $ String (x), loc)
    }
  } |
  loc=pos x=chrlit {
    fun (atr) {
      assertValue (atr, returnST $ Const (x), loc)
    }
  } |
  loc=pos n=decimal {
    fun (atr) {
      assertValue (atr, returnST $ Const (stringInt (n)), loc)
    }
  } |
  loc=pos func=lident args=inRoundBrackets[list0 (argParser)] {
    fun (atr) {
      assertValue (atr, chainST (args) => fun (tArgs) {Call (func, tArgs)}, loc)
    }
  } |
  loc=pos x=lident {
    fun (atr) {
      returnST $ case atr of
        Ref -> Ref (x)
      | Void -> Ignore (Var (x))
      | _ -> Var (x)
      esac
    }
  } |
  loc=pos name=uident args=inRoundBrackets[list0 (argParser)]? {
    fun (atr) {
      var realArgs = case args of
                       None -> {}
                     | Some (x) -> x
                     esac;
      assertValue (atr, chainST (realArgs) => fun (tRealArgs) {Sexp (name, tRealArgs)}, loc)
    }
  } |
  loc=pos kSkip {
    fun (atr) {
      assertVoid (atr, returnST $ Skip, loc)
    }
  } |
  kIf cond=exp kThen body=scopeExpr elseTail=elsePart {
    fun (atr) {
      chainST ({cond (Val), body (atr), elseTail (atr)}) => fun ({tCond, tBody, tElse}) {
        If (tCond, tBody, tElse)
      }
    }
  } |
  loc=pos kWhile cond=exp kDo body=scopeExpr kOd {
    fun (atr) {
      var node = chainST ({cond (Val), body (Void)}) => fun ({tCond, tBody}) {While (tCond, tBody)};
      assertVoid(atr, node, loc)
    }
  } |
  loc=pos kDo body=scopeExpr kWhile cond=exp kOd {
    fun (atr) {
      var node = chainST ({body (Void), cond (Val)}) => fun ({tBody, tCond}) {
        distributeScope (
          tBody,
          fun (loopBody) {
            DoWhile (loopBody, tCond)
          }
        )
      };
      assertVoid(atr, node, loc)
    }
  } |
 loc=pos kFor init=scopeExpr s[","] cond=exp s[","] step=exp kDo body=scopeExpr kOd {
   fun (atr) {
      var node = chainST ({init (Void), cond (Val), step (Void), body (Void)}) => fun ({tInit, tCond, tStep, tBody}) {
        var fullBody = Seq (tBody, tStep);
        var whilePart = While (tCond, fullBody);
        distributeScope (
          tInit,
          fun (initPart) {
            Seq (initPart, whilePart)
          }
        )  
      };
      assertVoid(atr, node, loc)
    }
  } |
  kCase scrutinee=exp kOf cases=listBy[caseParser, s("|")] kEsac {
    fun (atr) {
      var atrCases = map (fun (curCase) {curCase (atr)}, cases);
      scrutinee (Val) =>> fun (tScrutinee) {
      chainST (atrCases) =>> fun (tCases) {
      freshName => fun (tName) {
        var newDef = Var ({tName});
        var newAssn = Assn (Ref (tName), tScrutinee);
        var reifiedCases = reifyPatternBindings (tName, tCases);
        Scope({newDef}, Seq (Ignore (newAssn), Case (tName, reifiedCases)))
      }}}
    }
  } |
  inRoundBrackets[scopeExpr]
),
argParser = memo $ eta syntax (arg=exp {arg (Val)}),
elsePart = memo $ eta syntax (
  kElif cond=exp kThen body=scopeExpr elseTail=elsePart {
    fun (atr) {
      chainST ({cond (Val), body (atr), elseTail (atr)}) => fun ({tCond, tBody, tElse}) {
        If (tCond, tBody, tElse)
      }
    }
  } |
  kElse body=scopeExpr kFi {
    body
  } |
  loc=pos kFi {
    fun (atr) {
      assertVoid (atr, returnST $ Skip, loc)
    }
  }
),
patternPaser = memo $ eta syntax (
  s["_"] {
    Wildcard
  } |
  x=decimal {
    Const (stringInt (x))
  } |
  s["["] elems=list0[patternPaser] s["]"] {
    Array (elems)
  } |
  name=uident s["("] elems=list0[patternPaser] s[")"] {
    Sexp (name, elems)
  } |
  name=uident {
    Sexp (name, {})
  } |
  name=lident s["@"] pattern=patternPaser {
    Named (name, Some (pattern))
  } |
  name=lident {
    Named (name, None)
  }
),
caseParser = memo $ eta syntax (
  pattern=patternPaser s["->"] e=scopeExpr {
    fun (atr) {
      e (atr) => fun (tE) {[pattern, tE]}
    }
  }
),
varDef = memo $ eta syntax (
  x=lident {
    returnST $ [x, None]
  } |
  x=lident s["="] init=basic {
    init (Val) => fun (tInit) {[x, Some (tInit)]}
  }
),
genericDef = memo $ eta syntax (
  s["var"] varDefs=list[varDef] s[";"] {
    chainST (varDefs) => fun(tVarDefs) {Var (tVarDefs)}
  } |
  s["fun"] funName=lident args=inRoundBrackets[list0 (lident)] s["{"] body=scopeExpr s["}"] {
    body (Weak) => fun(tBody) {Fun (funName, args, tBody)}
  }
),
defenitions = memo $ eta syntax (
  headDef=genericDef tailDefs=defenitions {
    headDef : tailDefs
  } |
  headDef=genericDef {
    {headDef}
  }
),
scopeExpr = memo $ eta syntax (
  defs=defenitions e=exp {
    fun (atr) {
      chainST (defs) =>> fun (tDefs) {
      e (atr) => fun (tE) {
        expandScope (tDefs, tE)
      }}   
    }
  } |
  e=exp {
    fun (atr) {
      e (atr) => fun (tE) {Scope ({}, tE)}
    }
  } |
  loc=pos defs=defenitions {
    fun (atr) {
      chainST (defs) =>> fun (tDefs) {
      assertVoid(atr, returnST $ Skip, loc) => fun (tSkip) {
        expandScope(tDefs, tSkip)
      }}
    }
  }
),
basic = memo $ eta (expr (binopParsers, postfix)),
postfix = memo $ eta syntax (
  loc=pos e=primary ps=(i=inbr[s("["), exp, s("]")] {Index (i (Val))})* {
    fun (atr) {
      foldl(
        fun (e, p) {                                                                            
          case p of Index (i) ->
            fun (innerAtr) {
              case innerAtr of
                Ref -> e (Val) =>> fun (tE) {
                       i => fun (tI) {
                          ElemRef (tE, tI)
                       }}      
              | _   -> assertValue (innerAtr, e (Val) =>> fun (tE) {
                                              i => fun (tI) {
                                                  Elem (tE, tI)
                                              }}, loc)
              esac
            }
          esac                                                                            
        }, 
        e, 
        ps
      ) (atr)
    }
  }
),
exp = memo $ eta syntax (
  basic |
  s1=basic s[";"] s2=exp {
    fun (atr) {
      chainST ({s1 (Void), s2 (atr)}) => fun ({tS1, tS2}) {
        Seq (tS1, tS2)
      }
    }
  }
);

-- Public top-level parser
public parse = syntax (s=scopeExpr {s (Void) (emptyEnv ()) [1]});
