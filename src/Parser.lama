-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
        exp = memo $ eta expr ( { [ Left, { [s("!!"), fun (l, op, r) {Binop("!!", l, r)}]
					  }
				  ],
				  [ Left, { [s("&&"), fun (l, op, r) {Binop("&&", l, r)}]
					  }
				  ],
				  [ Nona, { [s("<"), fun (l, op, r) {Binop("<", l, r)}],
                                            [s(">"), fun (l, op, r) {Binop(">", l, r)}],
                                            [s("<="), fun (l, op, r) {Binop("<=", l, r)}],
                                            [s(">="), fun (l, op, r) {Binop(">=", l, r)}],
                                            [s("=="), fun (l, op, r) {Binop("==", l, r)}],
                                            [s("!="), fun (l, op, r) {Binop("!=", l, r)}]
					  }
				  ],
                                  [ Left, { [s("+"), fun (l, op, r) {Binop("+", l, r)}],
                                            [s("-"), fun (l, op, r) {Binop("-", l, r)}] 
                                          }
                                  ],
                                  [ Left, { [s("*"), fun (l, op, r) {Binop("*", l, r)}], 
                                            [s("/"), fun (l, op, r) {Binop("/", l, r)}],
                                            [s("%"), fun (l, op, r) {Binop("%", l, r)}]
                                          }
                                  ]
                                }, primary);

var stmtSimple = memo $ eta syntax (x=lident s[":="] y=exp {Assn(x, y)} | 
                                    kSkip {Skip} | 
                                    kRead x=inbr[s("("), lident, s(")")] {Read(x)} | 
                                    kWrite x=inbr[s("("), exp, s(")")] {Write(x)} );

var stmt = memo $ eta syntax(x=stmtSimple s[";"] y=stmt {Seq(x, y)} | stmtSimple);
   

-- Public top-level parser
public parse = stmt;
             
