-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopAbstract(op) {
  [s (op), fun (l, _, r) {Binop (op, l, r)}]
}

fun singleOp(op) {
  {binopAbstract(op)}
}

fun listOp(opList) {
  map (binopAbstract, opList)
}

fun leftFullOp(fullOp) {
  [Left, fullOp]
}

fun nonaFullOp(fullOp) {
  [Nona, fullOp]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr ({leftFullOp (singleOp ("!!")),
                               leftFullOp (singleOp ("&&")),
                               nonaFullOp (listOp ({"==", "!=", ">", "<", ">=", "<="})),
                               leftFullOp (listOp ({"+", "-"})),
                               leftFullOp (listOp ({"*", "/", "%"}))
                              }, primary));

var stmtSingle = memo $ eta syntax (v=lident s[":="] e=exp {Assn (v, e)}               |
                                    -kSkip {Skip}                                      |
                                    -kRead v=inbr[s ("("), lident, s (")")] {Read (v)} |
                                    -kWrite e=inbr[s ("("), exp, s (")")] {Write (e)});
   
var stmt = memo $ eta syntax (stmtSingle | sFirst=stmtSingle s[";"] sSecond=stmt {Seq (sFirst, sSecond)});

-- Public top-level parser
public parse = stmt;
             
