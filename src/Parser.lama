-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopExpr(op) {
  [s(op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s ("("), exp, s (")")]),
      exp = memo $ eta expr ({
                               [Left, map(binopExpr,{"&&", "!!"})],
                               [Nona, map(binopExpr,{"==", "!=", "<", "<=", ">", ">="})],
                               [Left, map(binopExpr,{"+", "-"})],
                               [Left, map(binopExpr,{"*", "/", "%"})]
                             },
                             primary);

var stmtSeq = memo $ eta syntax (stmt                              |
                                 x=stmt s[";"] y=stmtSeq {Seq (x, y)}),
      stmt = memo $ eta syntax(kRead x=inbr[s ("("), lident, s (")")]                                  {Read (x)} |
                               kWrite x=inbr[s ("("), exp, s (")")]                                   {Write (x)} |
                               kSkip                                                                       {Skip} |
                               kIf cond=exp kThen ifBr=stmtSeq elseBr=ifChain           {If (cond, ifBr, elseBr)} |
                               kWhile cond=exp kDo body=stmtSeq kOd                          {While (cond, body)} |
                               kDo body=stmtSeq kWhile cond=exp kOd                        {DoWhile (body, cond)} |
                               kFor init=stmtSeq s[","] cond=exp s[","] post=stmtSeq kDo body=stmtSeq kOd 
                                                                     {Seq (init, While (cond, Seq (body, post)))} |
                               x=lident s[":="] y=exp                                               {Assn (x, y)}),
      ifChain = memo $ eta syntax (kFi                                                                {Skip} |
                                   kElse elseBr=stmtSeq kFi                                         {elseBr} |
                                   kElif cond=exp kThen ifBr=stmtSeq elseBr=ifChain {If (cond, ifBr, elseBr)});


-- Public top-level parser
public parse = stmtSeq;
