-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun getInfixParsers (infs) {
	map (
		fun (inf) {
			[
				s (inf),
				fun (x, op, y) {
					case op of
						inf -> Binop (op, x, y)
					|	_ -> failure ("op /= inf")
					esac
				} 
			]
		},
		infs
	)
}

var infixParsers = {
	[
		Left, getInfixParsers ({"!!"})
	],
    [
    	Left, getInfixParsers ({"&&"})
    ],
    [
    	Nona, getInfixParsers ({"==", "!=", "<", ">", "<=", ">="})
    ],
    [
    	Left, getInfixParsers ({"+", "-"})
    ],
    [
    	Left, getInfixParsers ({"*", "/", "%"})
    ]
};

fun inOrdinaryBracketsParser (argParser) {
	inbr (s("("), argParser, s(")"))
}

var expressionBase = memo $ eta syntax (
	constValue=decimal {
		Const (stringInt (constValue))
	} |
	varName=lident {
		Var (varName)
	} |
	inOrdinaryBracketsParser[expression]
), expression = memo $ eta expr (infixParsers, expressionBase);

var singleStatement = memo $ eta syntax (
	varName=lident s[":="] exp=expression {
		Assn (varName, exp)
	} |
	kSkip {
		Skip
	} |
	kRead varName=inOrdinaryBracketsParser[lident] {
		Read (varName)
	} |
	kWrite exp=inOrdinaryBracketsParser[expression] {
		Write (exp)
	}
);

var stmt = memo $ eta syntax (
	singleStatement |
	headStatement=singleStatement s[";"] tailStatements=stmt {
		Seq (headStatement, tailStatements)
	}
);

-- Public top-level parser
public parse = stmt;