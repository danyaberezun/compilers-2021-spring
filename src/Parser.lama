-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun descInfo (op) {
  [s (op), fun (l, _, r) {Binop (op, l, r)}]
}

-- Primary expression
-- expr = Var   (string)             |
--        Const (int)                |
--        Binop (string, expr, expr)
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),

      descriptors = {[Left, {descInfo("!!")}],
                     [Left, {descInfo("&&")}],
                     [Nona, {descInfo("=="), descInfo("!="), descInfo("<="),
                             descInfo("<"), descInfo(">="), descInfo(">")}],
                     [Left, {descInfo("+"), descInfo("-")}],
                     [Left, {descInfo("*"), descInfo("/"), descInfo("%")}]
                    },
      exp = memo $ eta expr (descriptors, primary);

-- stmt = Assn   (string, expr)     | :=
--        Seq    (stmt, stmt)       | ;
--        Skip                      | eps
--        Read   (string)           | read()
--        Write  (expr)             | write ()
var one_stmt = memo $ eta syntax (
        name=lident s[":="] value=exp {Assn (name, value)} |
        -kSkip {Skip} |
        -kRead s["("] name=lident s[")"] {Read (name)} |
        -kWrite s["("] res=exp s[")"] {Write (res)}
      ),
      stmt = memo $ eta syntax (one_stmt | a=one_stmt s[";"] b=stmt {Seq (a, b)});

-- Public top-level parser
public parse = stmt;
             
