-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop(lhs, op, rhs) {Binop(op, lhs, rhs)}
fun getBinop(ops) {
  map(fun(op) {
    [ s(op), binop ]
  }, ops)
}
-- Primary expression
var primaryExprParser = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                           x=lident  {Var (x)}               |
                                           inbr[s("("), exprParser, s(")")]),
      exprParser       = memo $ eta (expr(
        {
          [ Left, getBinop({"!!"}) ],
          [ Left, getBinop({"&&"}) ],
          [ Nona, getBinop({"==", "!=", "<", ">", "<=", ">="}) ],
          [ Left, getBinop({"+", "-"}) ],
          [ Left, getBinop({"*", "/", "%"}) ]
        },
        primaryExprParser
      ));

var simpleStmtParser = memo $ eta syntax(
    kSkip { Skip } |
    kRead x=inbr[s("("), lident, s(")")] { Read(x) } |
    kWrite e=inbr[s("("), exprParser, s(")")] { Write(e) } |
    x=lident s[":="] e=exprParser { Assn(x, e) }
),
  stmtParser = memo $ eta syntax (
    simpleStmtParser | s1=simpleStmtParser s[";"] s2=stmtParser { Seq(s1, s2) }
);

-- Public top-level parser
public parse = stmtParser;
