-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;
import Buffer;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Casts an argument "value" of type Val to the expected type, if possible
fun assertValue (expectedType, value, loc) {
  case expectedType of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (value)
  | Val  -> value
  | Weak -> value
  esac
}

-- Casts an argument "void" of type Void to the expected type, if possible
fun assertVoid (expectedType, void, loc) {
  case expectedType of
    Void -> void
  | Val  -> error ("value expected", loc)
  | Ref  -> error ("reference expected", loc)
  | Weak -> Seq (void, Const (0))
  esac
}


-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Assn (Ref (ident), value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Var (ds)      ->
                 case expandDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inOrdinaryBrackets (p) {
  inbr (s ("("), p, s (")"))
}

fun getInfixParsers (ops) {
	map (
		fun (op) {
			[
				syntax (
					loc=pos parsedOp=s[op] {
						[loc, parsedOp]
					}
				),
				fun (leftGetter, [loc, parsedOp], rightGetter) {
	      	fun (expectedType) {
	      		case parsedOp of
	      			op ->
	      				var left = leftGetter (Val);
	      				var right = rightGetter (Val);
	      				var res = Binop (op, left, right);
	      				assertValue (expectedType, res, loc)
	      		|	_ -> failure ("Unexpected behaviour of parser")
	      		esac
	      	}
        }
  		]
		},
		ops
	)
}

var assnParser = {
	[
		syntax (
			pos -s[":="]
		),
    fun (refGetter, loc, valGetter) {
      fun (expectedType) {
      	var ref = refGetter (Ref);
      	var value = valGetter (Val);
      	var res = Assn (ref, value);
      	assertValue (expectedType, res, loc)
      }
    }
	]
};

var infixParsers = {
	[Right, assnParser],
  [Left, getInfixParsers ({"!!"})],
  [Left, getInfixParsers ({"&&"})],
  [Nona, getInfixParsers ({"==", "!=", "<", ">", "<=", ">="})],
  [Left, getInfixParsers ({"+", "-"})],
  [Left, getInfixParsers ({"*", "/", "%"})]
};

var primaryParser = memo $ eta syntax (
		loc=pos n=decimal {
			fun (expectedType) {
				var res = Const (stringInt (n));
				assertValue (expectedType, res, loc)
			}
		} |
		loc=pos funName=lident args=inOrdinaryBrackets[list0 (argParser)] {
			fun (expectedType) {
				var res = Call (funName, args);
				assertValue (expectedType, res, loc)
			}
		} |
		varName=lident {
			fun (expectedType) {
				case expectedType of
			    Ref -> Ref (varName)
			  | Void -> Skip
			  | Val -> Var (varName)
			  | Weak -> Var (varName)
			  esac
			}
		} |
		loc=pos kSkip {
			fun (expectedType) {
				assertVoid (expectedType, Skip, loc)
			}
		} |
		loc=pos kRead refGetter=inOrdinaryBrackets[expressionsParser] {
			fun (expectedType) {
				var ref = refGetter (Ref);
				var res = Read (ref);
				assertVoid (expectedType, res, loc)
			}
		} |
		loc=pos kWrite exprGetter=inOrdinaryBrackets[expressionsParser] {
			fun (expectedType) {
				var expr = exprGetter (Val);
				var res = Write (expr);
				assertVoid (expectedType, res, loc)
			}
		} |
		kIf condGetter=expressionsParser kThen thenGetter=scopeParser elseGetter=elseParser {
			fun (expectedType) {
				var cond = condGetter (Val);
				var thenBody = thenGetter (expectedType);
				var elseBody = elseGetter (expectedType);
				If (cond, thenBody, elseBody)
			}
		} |
		loc=pos kWhile condGetter=expressionsParser kDo bodyGetter=scopeParser kOd {
			fun (expectedType) {
				var cond = condGetter (Val);
				var body = bodyGetter (Void);
				var res = While (cond, body);
				assertVoid (expectedType, res, loc)
			}
		} |
		loc=pos kDo bodyGetter=scopeParser kWhile condGetter=expressionsParser kOd {
			fun (expectedType) {
				var cond = condGetter (Val);
				distributeScope (bodyGetter (Void), fun (body) {
					var resLoop = DoWhile (body, cond);
					assertVoid (expectedType, resLoop, loc)
				})
			}
		} |
		loc=pos kFor 
		initGetter=scopeParser s[","] condGetter=expressionsParser s[","] stepGetter=expressionsParser 
		kDo 
			bodyGetter=scopeParser
		kOd {
			fun (expectedType) {
				var cond = condGetter (Val);
				var body = bodyGetter (Void);
				var step = stepGetter (Void);
				var loopBody = Seq (body, step);
				var loop = While (cond, loopBody);
				distributeScope (initGetter (Void), fun (init) {
					var res = Seq (init, loop);
					assertVoid (expectedType, res, loc)
				})
			}
		} |
	  inOrdinaryBrackets[scopeParser]
  ),
  argParser = memo $ eta syntax (
  	argGetter=expressionsParser {
  		argGetter (Val)
  	}
  ),
  elseParser = memo $ eta syntax (
 		kElif condGetter=expressionsParser kThen thenGetter=scopeParser elseGetter=elseParser {
 			fun (expectedType) {
 				var cond = condGetter (Val);
 				var thenBody = thenGetter (expectedType);
 				var elseBody = elseGetter (expectedType);
 				If (cond, thenBody, elseBody)
 			}
 		} |
    -kElse scopeParser -kFi |
    loc=pos kFi {
    	fun (expectedType) {
    		assertVoid (expectedType, Skip, loc)
    	} 
    }
  ),
  singleVarDefinitionParser = memo $ eta syntax (
  	varName=lident {
  		[varName, None]
  	} |
  	varName=lident s["="] valGetter=singleExpressionParser {
  		var initValue = valGetter (Val);
  		[varName, Some (initValue)]
  	}
  ),
  definitionParser = memo $ eta syntax (
  	s["var"] varDefs=list[singleVarDefinitionParser] s[";"] {
  		Var (varDefs)
  	} |
  	s["fun"] funName=lident args=inOrdinaryBrackets[list0 (lident)] s["{"] 
  		bodyGetter=scopeParser 
  	s["}"] {
  		var body = bodyGetter (Weak);
  		Fun (funName, args, body)
  	}
  ),
  definitionsParser = memo $ eta syntax (
  	head=definitionParser tail=definitionsParser {
  		head : tail
  	} |
  	head=definitionParser {
  		{head}
  	}
  ),
  scopeParser = memo $ eta syntax (
  	definitions=definitionsParser expGetter=expressionsParser {
  		fun (expectedType) {
  			var mainExp = expGetter (expectedType);
  			expandScope (definitions, mainExp)
  		}
  	} | 
		expGetter=expressionsParser {
			fun (expectedType) {
				var resExp = expGetter (expectedType);
				Scope ({}, resExp)
			}
		}
  ),
  singleExpressionParser = memo $ eta (expr (infixParsers, primaryParser)),
  expressionsParser = memo $ eta syntax (
  	singleExpressionParser |
  	headGetter=singleExpressionParser s[";"] tailGetter=expressionsParser {
  		fun (expectedType) {
  			var head = headGetter (Void);
  			var tail = tailGetter (expectedType);
  			Seq (head, tail)
  		}
  	}
	);

-- Public top-level parser
public parse = syntax (
	scopeGetter=scopeParser {
		scopeGetter (Void)
	}
);