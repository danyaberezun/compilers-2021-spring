-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
-- NOTE: assert that Value inside "atr" context
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

-- NOTE: assert that Void inside "atr"
fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

fun orSkip (op, a) {
  case op of
    None -> Skip
  | Some (x) -> x (a)
  esac
}

var ifStmt = memo $ eta syntax (
  -kIf e=exp -kThen s=exp rest=elsePart? -kFi { fun (a) {If (e (Val), s (a), orSkip (rest, a))} }
);

var elsePart = memo $ eta syntax (
    -kElif e=exp -kThen s=exp rest=elsePart? { fun (a) {If (e (Val), s (a), orSkip (rest, a))} }
  | -kElse exp
);

var loopStmt = memo $ eta syntax (
    loc=pos -kWhile e=exp -kDo s=exp -kOd { fun (a) {assertVoid (a, While (e (Val), s (Void)), loc)} }
  | loc=pos -kDo s=exp -kWhile e=exp -kOd { fun (a) {DoWhile (s (Void), e (Val))}}
  | loc=pos -kFor init=exp -s[","] cond=exp -s[","] inc=exp  -kDo body=exp -kOd 
    { fun (a) {assertVoid (a, Seq ( init (Void), 
                                    While (cond (Val), 
                                    Seq (body (Void), 
                                         inc (Void)))), loc)} }
);

var primary  = memo $ eta syntax (
  -- N
    loc=pos x=decimal { fun (a) {assertValue (a, Const (stringInt (x)), loc)} }
  -- identifier
  | x=lident { fun (a) {
      case a of
        Ref  -> Ref (x)
      | Void -> Ignore (Var (x))
      | _    -> Var (x)
      esac}}
  -- ( exp )
  | -s["("] e=exp -s[")"]
  -- skip
  | loc=pos -kSkip { fun (a) {assertVoid (a, Skip, loc)}}
  -- \epsion
  -- | -kRead -bl name=lident -br {Read (name)}
  | loc=pos -kRead -s["("] name=lident -s[")"]  { fun (a) {assertVoid (a, Read (name), loc)} }
  -- | -kWrite -bl e=exp -br {Write (e)}
  | loc=pos -kWrite -s["("] e=exp -s[")"]  { fun (a) {assertVoid (a, Write (e (Val)), loc)} }
  -- control flow
  | ifStmt
  | loopStmt
  );

var basic = memo $ eta (expr ({
  [Right, {[s (":="), fun (l, loc, r) { 
                        fun (a) {assertValue (a, Assn (l (Ref), r (Val)), loc)} }]}],
  [Left , map (binop, {"!!"})],
  [Left , map (binop, {"&&"})],
  [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
  [Left , map (binop, {"+", "-"})],
  [Left , map (binop, {"*", "/", "%"})]},
  primary));

var exp = memo $ eta syntax (
    basic -s[";"]?
  | s1=basic -s[";"] s2=exp { fun (a) {Seq (s1 (Void), s2 (a))}}
);

-- Public top-level parser
public parse = syntax (e=exp {e (Void)});