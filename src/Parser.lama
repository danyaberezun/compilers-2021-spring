-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Casts an argument "value" of type Val to the expected type, if possible
fun assertValue (expectedType, value, loc) {
  case expectedType of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (value)
  | Val  -> value
  esac
}

-- Casts an argument "void" of type Void to the expected type, if possible
fun assertVoid (expectedType, void, loc) {
  case expectedType of
    Void -> void
  | Val  -> error ("value expected", loc)
  | Ref  -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inOrdinaryBrackets (p) {
  inbr (s ("("), p, s (")"))
}

fun getInfixParsers (ops) {
	map (
		fun (op) {
			[
				syntax (
					loc=pos parsedOp=s[op] {
						[loc, parsedOp]
					}
				),
				fun (leftGetter, [loc, parsedOp], rightGetter) {
	      	fun (expectedType) {
	      		case parsedOp of
	      			op ->
	      				var left = leftGetter (Val);
	      				var right = rightGetter (Val);
	      				var res = Binop (op, left, right);
	      				assertValue (expectedType, res, loc)
	      		|	_ -> failure ("Unexpected behaviour of parser")
	      		esac
	      	}
        }
  		]
		},
		ops
	)
}

var assnParser = {
	[
		syntax (
			pos -s[":="]
		),
    fun (refGetter, loc, valGetter) {
      fun (expectedType) {
      	var ref = refGetter (Ref);
      	var value = valGetter (Val);
      	var res = Assn (ref, value);
      	assertValue (expectedType, res, loc)
      }
    }
	]
};

var infixParsers = {
	[Right, assnParser],
  [Left, getInfixParsers ({"!!"})],
  [Left, getInfixParsers ({"&&"})],
  [Nona, getInfixParsers ({"==", "!=", "<", ">", "<=", ">="})],
  [Left, getInfixParsers ({"+", "-"})],
  [Left, getInfixParsers ({"*", "/", "%"})]
};

var primaryParser = memo $ eta syntax (
			loc=pos n=decimal {
				fun (expectedType) {
					var res = Const (stringInt (n));
					assertValue (expectedType, res, loc)
				}
			} |
			varName=lident {
				fun (expectedType) {
					case expectedType of
				    Ref  -> Ref (varName)
				  | Void -> Skip
				  | Val  -> Var (varName)
				  esac
				}
			} |
			loc=pos kSkip {
				fun (expectedType) {
					assertVoid (expectedType, Skip, loc)
				}
			} |
			loc=pos kRead refGetter=inOrdinaryBrackets[expressionsParser] {
				fun (expectedType) {
					var ref = refGetter (Ref);
					var res = Read (ref);
					assertVoid (expectedType, res, loc)
				}
			} |
			loc=pos kWrite expGetter=inOrdinaryBrackets[expressionsParser] {
				fun (expectedType) {
					var exp = expGetter (Val);
					var res = Write (exp);
					assertVoid (expectedType, res, loc)
				}
			} |
			kIf condGetter=expressionsParser kThen bodyGetter=expressionsParser elseGetter=elseParser {
      	fun (expectedType) {
      		var cond = condGetter (Val);
      		var body = bodyGetter (expectedType);
      		var curElse = elseGetter (expectedType);
      		If (cond, body, curElse)
      	}
      } |
      loc=pos kWhile condGetter=expressionsParser kDo bodyGetter=expressionsParser kOd {
      	fun (expectedType) {
      		var cond = condGetter (Val);
      		var body = bodyGetter (Void);
      		var res = While (cond, body);
      		assertVoid (expectedType, res, loc)
      	}
      } |
      loc=pos kDo bodyGetter=expressionsParser kWhile condGetter=expressionsParser kOd {
      	fun (expectedType) {
      		var body = bodyGetter (Void);
      		var cond = condGetter (Val);
      		var res = DoWhile (body, cond);
      		assertVoid (expectedType, res, loc)
      	}
      } |
      loc=pos 
      kFor initGetter=expressionsParser s[","] 
      condGetter=expressionsParser s[","] stepGetter=expressionsParser kDo 
      	bodyGetter=expressionsParser
      kOd {
      	fun (expectedType) {
      		var init = initGetter (Void);
      		var cond = condGetter (Val);
      		var step = stepGetter (Void);
      		var body = bodyGetter (Void);
      		var loopBody = Seq (body, step);
      		var loop = While (cond, loopBody);
      		var res = Seq (init, loop);
      		assertVoid (expectedType, res, loc)
      	}
      } |
      inOrdinaryBrackets[expressionsParser]
    ),
    elseParser = memo $ eta syntax (
    	kElif condGetter=expressionsParser kThen bodyGetter=expressionsParser elseGetter=elseParser {
    		fun (expectedType) {
    			var cond = condGetter (Val);
    			var body = bodyGetter (expectedType);
    			var curElse = elseGetter (expectedType);
    			If (cond, body, curElse)
    		}
    	} |
      -kElse expressionsParser -kFi |
      loc=pos kFi { 
      	fun (expectedType) {
      		assertVoid (expectedType, Skip, loc)
      	}
      }
   	),
    singleExpressionParser = memo $ eta (expr (infixParsers, primaryParser)),
    expressionsParser = memo $ eta syntax (
    	singleExpressionParser |
    	headExpressionGetter=singleExpressionParser s[";"] tailExpressionsGetter=expressionsParser {
    		fun (expectedType) {
    			var headExpression = headExpressionGetter (Void);
    			var tailExpressions = tailExpressionsGetter (expectedType);
    			Seq (headExpression, tailExpressions)
    		}
    	}
   	);

-- Public top-level parser
public parse = syntax (
	expressionsGetter=expressionsParser {
		expressionsGetter (Void)
	}
);