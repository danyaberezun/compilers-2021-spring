-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

infix <| after |> (a, b) { syntax (a -b) } 

-- eta :: (a -> x) -> (a -> x)

var bl = s ("("), br = s (")");

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[bl, exp, br]),
    op = fun (ss) {
      [s (ss), fun (l, _, r) {Binop (ss, l, r)}]
    },

    ops = { [Left, {op("!!")}]
          , [Left, {op("&&")}]
          , [Nona, {op("=="), op("!="), op("<="), op("<"), op(">="), op(">")}]
          , [Left, {op("+"), op("-")}]
          , [Left, {op("*"), op("/"), op("%")}]
          },
    exp = memo $ expr (ops, primary);

    -- exp0 = memo $ eta syntax (a=exp op=$(s ("+")) b=exp {Binop (op, a, b)} | primary),
    -- exp = exp0;

fun orSkip (op) {
  case op of
    None -> Skip
  | Some (x) -> x
  esac
}

var ifStmt = memo $ eta syntax (
  -kIf e=exp -kThen s=stmt rest=elsePart? -kFi {If (e, s, orSkip (rest))}
);

var elsePart = memo $ eta syntax (
    -kElif e=exp -kThen s=stmt rest=elsePart? {If (e, s, orSkip (rest))}
  | -kElse stmt
);

var loopStmt = memo $ eta syntax (
    -kWhile e=exp -kDo s=stmt -kOd {While (e, s)}
  | -kDo s=stmt -kWhile e=exp -kOd {DoWhile (s, e)}
  | -kFor init=stmt -$(s (",")) cond=exp -$(s (",")) inc=stmt 
    -kDo body=stmt -kOd
    { Seq (init, While (cond, Seq (body, inc))) }
);

var oneStmt = memo $ eta syntax (
    name=lident -$(s (":=")) e=exp {Assn (name, e)}
  | -kSkip {Skip}
  | -kWrite -bl e=exp -br {Write (e)}
  | -kRead -bl name=lident -br {Read (name)}
  | empty {Skip}
  -- | controlFlow
  | ifStmt
  | loopStmt
);

var stmt = memo $ eta syntax (
    x=oneStmt -$(s (";")) xs=stmt {Seq (x, xs)}
  | oneStmt
);

-- Public top-level parser
public parse = memo $ eta syntax (stmt -end);

