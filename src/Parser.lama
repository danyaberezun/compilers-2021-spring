-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun descInfo (op) {
  [s (op), fun (l, _, r) {Binop (op, l, r)}]
}

-- Primary expression
-- expr = Var   (string)             |
--        Const (int)                |
--        Binop (string, expr, expr)
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),

      descriptors = {[Left, {descInfo("!!")}],
                     [Left, {descInfo("&&")}],
                     [Nona, {descInfo("=="), descInfo("!="), descInfo("<="),
                             descInfo("<"), descInfo(">="), descInfo(">")}],
                     [Left, {descInfo("+"), descInfo("-")}],
                     [Left, {descInfo("*"), descInfo("/"), descInfo("%")}]
                    },
      exp = memo $ eta expr (descriptors, primary);

-- stmt = Assn    (string, expr)     |
--        Seq     (stmt, stmt)       |
--        Skip                       |
--        Read    (string)           |
--        Write   (expr)             |
--        If      (expr, stmt, stmt) |
--        While   (expr, stmt)       |
--        DoWhile (stmt, expr)

fun branchOrSkip (opt) {
  case opt of
    None -> Skip
  | Some (v) -> v
  esac
}

var ifPart = memo $ eta syntax (
        -kIf cond=exp -kThen ifBranch=stmt elseBranches=elsePart? -kFi { If (cond, ifBranch, branchOrSkip (elseBranches)) }
      ),
    elsePart = memo $ eta syntax (
        -kElif cond=exp -kThen elifBranch=stmt tail=elsePart? { If (cond, elifBranch, branchOrSkip (tail)) } |
        -kElse elseBranch=stmt
      ),
    whileDo = memo $ eta syntax (
        -kWhile cond=exp -kDo loopCode=stmt -kOd { While (cond, loopCode) }
      ),
    doWhile = memo $ eta syntax (
        -kDo loopCode=stmt -kWhile cond=exp -kOd { DoWhile (loopCode, cond) }
      ),
    forExpr = memo $ eta syntax (
        -kFor start=stmt s[","] cond=exp s[","] ending=stmt -kDo loopCode=stmt -kOd
        { Seq (start, While (cond, Seq (loopCode, ending))) }
      ),
    oneStmt = memo $ eta syntax (
        name=lident s[":="] value=exp {Assn (name, value)} |
        -kSkip {Skip} |
        -kRead s["("] name=lident s[")"] {Read (name)} |
        -kWrite s["("] res=exp s[")"] {Write (res)} |
        -kIf cond=exp |
        ifPart |
        whileDo | doWhile | forExpr
      ),
      stmt = memo $ eta syntax (oneStmt | a=oneStmt s[";"] b=stmt {Seq (a, b)});

-- Public top-level parser
public parse = stmt;
