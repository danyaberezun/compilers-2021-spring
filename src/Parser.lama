-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- _(p)_ -> p
fun par (p) {
  inbr (s ("("), p, s (")"))
}

fun binop (op) {
  [s (op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s ("("), exp, s (")")]);

--failure ("expression parsing not implemented\n")
var exp = memo $ eta (expr (
  {
    [Left, map (binop, {"!!"})],
    [Left, map (binop, {"&&"})],
    [Nona, map (binop, {"==", "!=", "<=", "<", ">=", ">"})],
    [Left, map (binop, {"+", "-"})],
    [Left, map (binop, {"*", "/", "%"})]
  },
  primary
));

var stmt_sin = memo $ eta syntax (
    kSkip {Skip}
  | x=lident s[":="] e=exp {Assn (x, e)}
  | kRead x=par[lident] {Read (x)}
  | kWrite e=par[exp] {Write (e)}
);

var stmt_seq = memo $ eta syntax (
  s1=stmt_sin s[";"] s2=(stmt_sin | stmt_seq) {Seq (s1, s2)}
);

--failure ("statement parsing not implemented\n")
var stmt = memo $ eta syntax (stmt_sin | stmt_seq);

-- Public top-level parser
public parse = stmt;
