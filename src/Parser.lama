-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

infix <| after |> (a, b) { syntax (a -b) } 

-- eta :: (a -> x) -> (a -> x)

var bl = s ("("), br = s (")");

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[bl, exp, br]),
    op = fun (ss) {
      [s (ss), fun (l, _, r) {Binop (ss, l, r)}]
    },

    ops = { [Left, {op("!!")}]
          , [Left, {op("&&")}]
          , [Nona, {op("=="), op("!="), op("<="), op("<"), op(">="), op(">")}]
          , [Left, {op("+"), op("-")}]
          , [Left, {op("*"), op("/"), op("%")}]
          },
    exp = memo $ expr (ops, primary);

    -- exp0 = memo $ eta syntax (a=exp op=$(s ("+")) b=exp {Binop (op, a, b)} | primary),
    -- exp = exp0;

var stmt = memo $ eta syntax (
    name=lident -$(s (":=")) e=exp {Assn (name, e)}
  | -kSkip {Skip}
  | -kWrite -bl e=exp -br {Write (e)}
  | -kRead -bl name=lident -br {Read (name)}
  | empty
);

var stmts = memo $ eta syntax (
    x=stmt -$(s (";")) xs=stmts {Seq (x, xs)}
  | stmt -end
);

-- Public top-level parser
public parse = stmts;

