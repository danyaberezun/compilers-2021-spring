-- Expression evaluator

import List;
import State;
import World;

-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values
fun evalList (c, exprs) {
  case foldl (fun ([c, vals], e) {
                case eval (c, e) of
                  [c, v] -> [c, v : vals]
                esac
              },
              [c, {}],
              exprs) of
    [c, vals] -> [c, reverse (vals)]
  esac
}

public fun evalBinop(op, a, b) {
  case op of
    "+" -> a + b
  | "-" -> a - b
  | "/" -> a / b
  | "*" -> a * b
  | "%" -> a % b
  | "&&" -> a && b
  | "!!" -> a !! b
  | "==" -> a == b
  | "!=" -> a != b
  | ">=" -> a >= b
  | ">" -> a > b
  | "<" -> a < b
  | "<=" -> a <= b
  esac
}
 
fun executeWhile (c, cond, body) {
  var condEvalResult = eval (c, cond);
  var newC = condEvalResult.fst;
  case condEvalResult.snd of
    0 -> [c, Void]
  | _ ->
      var bodyEvalResult = eval (newC, body);
      var finalC = bodyEvalResult.fst;
      case bodyEvalResult.snd of
        Void -> executeWhile (finalC, cond, body)
      | _ -> failure ("While/DoWhile body must return Void")
      esac
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn    (expr, expr)         |
--        Seq     (expr, expr)         |
--        Skip                         |
--        Read    (string)             |
--        Write   (expr)               |
--        If      (expr, expr, expr)   |
--        While   (expr, expr)         |
--        DoWhile (expr, expr)         |
--        Var     (string)             |
--        Ref     (string)             |
--        Const   (int)                |
--        Binop   (string, expr, expr) |
--        Ignore  (expr)
fun eval (c, expr) {
  case expr of
    Assn (refExpr, valueExpr) ->
      case evalList (c, {refExpr, valueExpr}) of
        [[newState, newWorld], {ref, value}] ->
          var finalState = newState <- [ref, value];
          var finalC = [finalState, newWorld];
          [finalC, value]
        esac
  | Seq (beforeExpr, afterExpr) ->
      case evalList (c, {beforeExpr, afterExpr}) of 
        [newC, {Void, res}] -> [newC, res]
      | _ -> failure ("First part of Seq must return Void") 
      esac
  | Skip -> [c, Void]
  | Read (varExpr) ->
      var varEvalResult = eval (c, varExpr);
      var newC = varEvalResult.fst;
      var varName = varEvalResult.snd;
      var newState = newC.fst;
      var newWorld = newC.snd;
 
      var readResult = readWorld (newWorld);
      var finalWorld = readResult.snd;
      var value = readResult.fst;
 
      var finalState = newState <- [varName, value];
      var finalC = [finalState, finalWorld];
      [finalC, Void]
  | Write (expr) ->
      var evalResult = eval (c, expr);
      var newC = evalResult.fst;
      var value = evalResult.snd;
      var newState = newC.fst;
      var newWorld = newC.snd;
 
      var finalWorld = writeWorld (value, newWorld);
      var finalC = [newState, finalWorld];
      [finalC, Void]
  | If (cond, ifBody, elseBody) ->
      var condEvalResult = eval (c, cond);
      var newC = condEvalResult.fst;
      case condEvalResult.snd of
        0 -> eval (newC, elseBody)
      | _ -> eval (newC, ifBody)
      esac
  | While (cond, body) -> executeWhile (c, cond, body)
  | DoWhile (body, cond) ->
      var bodyEvalResult = eval (c, body);
      var newC = bodyEvalResult.fst;
      case bodyEvalResult.snd of
        Void -> executeWhile (newC, cond, body)
      | _ -> failure ("DoWhile body must return Void")
      esac
  | Var (varName) ->
      var state = c.fst;
      [c, state (varName)]
  | Ref (refName) -> [c, refName]
  | Const (n) -> [c, n]
  | Binop (op, aExpr, bExpr) ->
      case evalList (c, {aExpr, bExpr}) of
        [newC, {a, b}] -> [newC, evalBinop (op, a, b)]
      esac
  | Ignore (expr) ->
      var evalRes = eval (c, expr);
      var newC = evalRes.fst;
      [newC, Void]
  esac
}
 
 
-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  case eval ([emptyState, createWorld (input)], expr) of
    [[_, w], Void] -> getOutput (w)
  | [_, _] -> failure ("The whole program must return Void")
  esac
}