-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
  case insns of
    READ : ins         -> case readWorld (c[2]) of
        [n, w] -> eval(env, [n : c[0], c[1], w], ins)
      esac
  | WRITE : ins        -> case c[0] of
        n : s -> eval (env, [s, c[1], writeWorld (n, c[2])], ins)
      esac
  | BINOP (s) : ins    -> case c[0] of
        y : x : xs -> eval (env, [evalOp (s, x, y) : xs, c[1], c[2]], ins)
      esac
  | LD    (v) : ins    -> case c[1] (v) of
        x -> eval (env, [x : c[0], c[1], c[2]], ins)
      esac
  | ST    (v) : ins    -> case c[0] of
        x : xs -> eval (env, [c[0], c[1] <- [v, x], c[2]], ins)
      esac
  | CONST (n) : ins    -> eval (env, [n : c[0], c[1], c[2]], ins)
  | LABEL (l) : ins    -> eval (env, c, ins)
  | JMP   (l) : ins    -> eval (env, c, fromLabel (env, l))
  | CJMP  ("nz", l) : ins -> case c[0] of
                               0 : xs -> eval (env, [xs, c[1], c[2]], ins)
                             | _ : xs -> eval (env, [xs, c[1], c[2]], fromLabel (env, l))  
                             esac
  | CJMP  ("z", l) : ins -> case c[0] of
                              0 : xs -> eval (env, [xs, c[1], c[2]], fromLabel (env, l))
                            | _ : xs -> eval (env, [xs, c[1], c[2]], ins) 
                            esac
  | LDA (x) : ins -> eval (env, [Ref (x) : c[0], c[1], c[2]], ins)
  | STI : ins -> case c[0] of
                   v : Ref (x) : xs -> eval (env, [v : xs, c[1] <- [x, v], c[2]], ins)
                 esac
  | DROP : ins -> case c[0] of v :xs -> eval (env, [xs, c[1], c[2]], ins) esac
  | _ -> c
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  --printf (showSM (insns));
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun compileSMReq (env, stmt) {
    case stmt of
      Var   (v)          -> [singletonBuffer (LD (v)), env]
    | Const (n)          -> [singletonBuffer (CONST (n)), env]
    | Binop (op, e1, e2) -> case compileSMReq (env, e1) of
                              [b1, env1] -> case compileSMReq (env1, e2) of
                                              [b2, env2] -> [b1 <+> b2 <+ BINOP (op), env2]
                                            esac
                            esac
    | Skip -> [emptyBuffer (), env]
    | Assn  (v, e)   -> case v of
                          Ref (x) -> case compileSMReq (env, e) of [b, env1] -> [b <+ ST (x), env1] esac
                        | _ -> case compileSMReq (env, v) of [b1, env1] -> case compileSMReq (env1, e) of [b2, env2] -> 
                                                                            [(b1 <+> b2) <+ STI, env2] esac esac
                        esac 
    | Seq   (s1, s2) -> case compileSMReq (env, s1) of [b1, env1] -> case compileSMReq (env1, s2) of [b2, env2] -> [b1 <+> b2, env2] esac esac         
    | Read  (v)      -> [listBuffer ({READ, ST (v), DROP}), env]
    | Write (e)      -> [addBuffer (compileSMReq (env, e)[0], WRITE), env]
    | While (e, s)   -> case genLabels (env, 2) of 
                          [l1, l2, env1] -> case compileSMReq (env1, s) of 
                                              [b, env2] -> [{JMP (l1), LABEL (l2), b . getBuffer, LABEL (l1), compileSM (e), 
                                              CJMP ("nz", l2)} . deepFlatten . listBuffer, env2]
                                            esac
                        esac
    | If (e, s1, s2) -> 
            case genLabels(env, 2) of [ls2, lexit, env1] ->
              case compileSMReq(env1, s1) of [cs1, env2] ->
                case compileSMReq(env2, s2) of [cs2, env3] ->
                  [{compileSM(e), CJMP("z", ls2), cs1 . getBuffer, JMP(lexit), LABEL(ls2), cs2 . getBuffer, LABEL(lexit)} .deepFlatten . listBuffer, env3]
                esac
              esac 
            esac
    | DoWhile (s, e)   -> case env . genLabel of 
                          [l, env1] -> case compileSMReq (env1, s) of 
                                              [b, env2] -> [{LABEL (l), b . getBuffer, compileSM (e), 
                                              CJMP ("nz", l)} . deepFlatten . listBuffer, env2]
                                            esac
                        esac
    | Ignore (e) -> case compileSMReq (env, e) of [b, env1] -> [b <+ DROP, env1] esac
    | Ref (v) -> [singletonBuffer (LDA (v)), env]
    | _ -> [emptyBuffer (), env]
    esac
  }

  compileSMReq (initCompEnv (), stmt)[0] . getBuffer
}
