-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> x
    esac
  }

  case i of
    READ             -> "READ"
  | WRITE            -> "WRITE"
  | BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | STI              -> "STI"
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (s)       -> sprintf ("LABEL %s", s)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (c, l)    -> sprintf ("CJMP %s, %s", c, l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, w, insns) {
  -- Global state maps names of global variables to values
  var globalState = ref (fun (x) {error (sprintf ("name ""%s"" is undefined", x), getLoc (x))});

  -- Make a fresh local state: a pair of arrays for arguments and local variables;
  -- takes the numbers of arguments and local variables respectively
  fun makeState (a, l) {
    [initArray (a, fun (_) {0}), initArray (l, fun (_) {0})]
  }

  -- Lookups a location in local/global states
  fun lookup ([args, locs], loc) {
    case loc of
      Arg (i) -> args[i]
    | Loc (i) -> locs[i]
    | Glb (x) -> deref (globalState) (x)
    esac
  }

  -- Assigns a value to a location
  fun assign ([args, locs], loc, v) {
    case loc of
      Arg (i) -> args[i] := v
    | Loc (i) -> locs[i] := v
    | Glb (x) -> var g = deref (globalState);
                 globalState ::= fun (y) {if compare (x, y) == 0 then v else g (y) fi}
    esac
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take (list, n) {
    fun inner (n, acc, list) {
      if n == 0
      then [list, acc]
      else inner (n-1, list.hd : acc, list.tl)
      fi
    }

    inner (n, {}, list)
  }

  fun eval (c@[s, cst, st, w], insns) {
    case insns of
      {} -> c
    | x:xs ->
      case x of
        JMP (x) -> eval (c, fromLabel (env, x))
      | CJMP (cond, x) -> 
          var s = pop (c);
          case [cond, s[0]] of
            ["z", 0]  -> eval (s[1], fromLabel (env, x))
          | ["nz", 1] -> eval (s[1], fromLabel (env, x))
          | _         -> eval (s[1], xs)
          esac
      | CALL (f, a) -> eval ([s, [st, xs]:cst, st, w], fromLabel (env, f))
      | END -> 
          case cst of
            [st1, insns]:cst -> eval ([s, cst, st1, w], insns)
          | {} -> c
          esac
      | _ -> eval (evalInsn (c, x), xs)
      esac
    esac
  }
  
  fun addGlobal (st, x) {
    assign (st, Glb (x), 0);
    st
  }

  fun evalInsn (c@[s, cst, st, w], insn) {
    case insn of
      READ              -> read (c)
    | WRITE             -> write (c)
    | BINOP  (op)       -> binop (op, c)
    | LD     (x)        -> push (lookup (st, x), c)
    | LDA    (x)        -> [x:s, cst, st, w]
    | ST     (x)        -> popAndAssign (x, c)
    | STI               -> sti (c)
    | CONST  (n)        -> push (n, c)
    | DROP              -> pop (c)[1]
    | DUP               -> push (s[0], c)
    | GLOBAL (x)        -> [s, cst, addGlobal (st, x), w]
    | LABEL  (x)        -> c
    | BEGIN  (f, a, l)  -> createBeginConfiguration (take (s, a), c, a, l)
    esac
  }

  fun createBeginConfiguration ([s1, vals], c@[s, cst, st, w], a, l) {
    var st1 = makeState (a, l);
    foldl (
      fun (i, v) {
        assign (st1, Arg (i), v);
        i + 1  
      },
      0,
      vals
    );
    [s1, cst, st1, w]
  } 

  fun binop (op, c) {
    var y = pop (c);
    var x = pop (y[1]);
    push (evalOp (op, x[0], y[0]), x[1])
  }

  fun read (c@[s, cst, st, w]) {
    var r = readWorld (w);
    [r[0]:s, cst, st, r[1]]
  }

  fun write (c@[s, cst, st, w]) {
    var x = pop (c);
    [x[1][0], cst, st, writeWorld (x[0], w)]
  }

  fun pop ([n:s, cst, st, w]) {
    [n, [s, cst, st, w]]
  }

  fun popAndAssign (x, [n:s, cst, st, w]) {
    assign (st, x, n);
    [s, cst, st, w]
  }

  fun push (n, c@[s, cst, st, w]) {
    [n:s, cst, st, w]
  }

  fun sti ([n:x:s, cst, st, w]) {
    assign (st, x, n);
    [n:s, cst, st, w]
  }

  eval ([{}, {}, makeState (0, 0), w], insns) [3].getOutput
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), createWorld (input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [sprintf ("L%d", nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
  }

  -- Adds a new function
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScope (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScope (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar (name) {
    if scopeDepth == 1
    then makeCompEnv (nLabels, scopeDepth, addName (state, name, Glb (name)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addName (state, name, Loc (nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }

  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 1, enterFunction (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [functions, makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, {})]
  }

  -- Lookups a name of a variable
  fun lookupVar (name) {
    case lookup (state, name) of
      Fun (_, _) -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookup (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if scopeDepth == 1
     then [sprintf ("L%s", name),             makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions)]
     else [sprintf ("L%s_%d", name, nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
     fi
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 1
  }

  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel (env) {
  env [0] ()
}

fun rememberFun (env, name, args, body) {
  env [1] (name, args, body)
}

fun beginScope (env) {
  env [2] ()
}

fun endScope (env) {
  env [3] ()
}

fun addArg (env, name) {
  env [4] (name)
}

fun addVar (env, name) {
  env [5] (name)
}

fun beginFun (env, state) {
  env [6] (state)
}

fun getFuns (env) {
  env [7] ()
}

fun lookupVar (env, name) {
  env [8] (name)
}

fun lookupFun (env, name) {
  env [9] (name)
}

fun getLocals (env) {
  env [10] ()
}

fun genFunLabel (env, name) {
  env [11] (name)
}

fun addFun (env, name, fLabel, nargs) {
  env [12] (name, fLabel, nargs)
}

fun isGlobal (env) {
  env [13] ()
}

-- Helper function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case genLabel (env) of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
  foldl (fun (env, name) {addArg (env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars (env, names) {
  foldl (fun (env, name) {addVar (env, name)}, env, names)
}

var stmtCompEnv = initCompEnv ();

fun genLabelsAndUpdateEnv (n) {
  var labels = genLabels (stmtCompEnv, n);
  stmtCompEnv := labels[n];
  labels
}

fun genFunLabelAndUpdateEnv (f) {
  case genFunLabel (stmtCompEnv, f) of
    [l, env] ->
      stmtCompEnv := env;
      l
  esac
}

fun compileSMWithBuf (stmt) {
  case stmt of
    Assn    (x, expr)            -> compileSMWithBuf (x) <+> compileSMWithBuf (expr) <+ STI
  | Seq     (stmt1, stmt2)       -> compileSMWithBuf (stmt1) <+> compileSMWithBuf (stmt2)
  | Skip                         -> emptyBuffer ()
  | Read    (x)                  -> listBuffer ({READ, ST (lookupVar (stmtCompEnv, x))})
  | Write   (expr)               -> compileSMWithBuf (expr) <+ WRITE
  | If      (expr, stmt1, stmt2) -> compileIf (genLabelsAndUpdateEnv (2), expr, stmt1, stmt2)
  | While   (expr, stmt1)        -> compileWhile (genLabelsAndUpdateEnv (2), expr, stmt1)
  | DoWhile (stmt1, expr)        -> compileDoWhile (genLabelsAndUpdateEnv (1), stmt1, expr)
  | Var     (x)                  -> singletonBuffer (LD (lookupVar (stmtCompEnv, x)))
  | Ref     (x)                  -> singletonBuffer (LDA (lookupVar (stmtCompEnv, x)))
  | Const   (i)                  -> singletonBuffer (CONST (i))
  | Binop   (op, expr1, expr2)   -> compileSMWithBuf (expr1) <+> compileSMWithBuf (expr2) <+ BINOP (op)
  | Ignore  (expr)               -> compileSMWithBuf (expr) <+ DROP
  | Scope   (defs, expr)         -> compileScope (defs, expr)
  | Call    (f, exprs)           -> compileCall (f, exprs)
  esac
}

fun getFunInfosAndCode (defs) {
  foldl (
    fun ([infos, code], def) {
      case def of 
        Var (names)         ->
          stmtCompEnv := addVars (stmtCompEnv, names);
          if isGlobal (stmtCompEnv)
          then [infos, code <+> listBuffer (map (fun (x) { GLOBAL (x) }, names))]
          else [infos, code]
          fi
      | Fun (f, args, expr) ->
          var l = genFunLabelAndUpdateEnv (f);
          stmtCompEnv := addFun (stmtCompEnv, f, l, size (args));
          [[l, args, expr]:infos, code]
      esac
    }, 
    [{}, emptyBuffer ()], 
    defs
  )
}

fun compileScope (defs, expr) {
  stmtCompEnv := beginScope (stmtCompEnv);
  case getFunInfosAndCode (defs) of
    [infos, code] ->
      stmtCompEnv := foldl ( 
        fun (env, funInfo) {
          case funInfo of
            [l, args, expr] -> rememberFun (env, l, args, expr)
          esac
        },
        stmtCompEnv,
        infos
      );
      code := (code <+> compileSMWithBuf (expr));
      stmtCompEnv := endScope (stmtCompEnv);
      code
  esac
}

fun compileCall (f, exprs) {
  case lookupFun (stmtCompEnv, f) of
    Fun (l, a) -> 
      foldl (fun (buf, e) { buf <+> compileSMWithBuf (e) }, emptyBuffer (), exprs) <+ CALL (l, a)
  esac
}

fun compileWhile (labels@[startL, bodyL, env], expr, stmt) {
  singletonBuffer (JMP (startL)) <+
    LABEL (bodyL) <+>
    compileSMWithBuf (stmt) <+
    LABEL (startL) <+>
    compileSMWithBuf (expr) <+
    CJMP ("nz", bodyL)
}

fun compileDoWhile (labels@[bodyL, env], stmt, expr) {
  singletonBuffer (LABEL (bodyL)) <+>
    compileSMWithBuf (stmt) <+>
    compileSMWithBuf (expr) <+
    CJMP ("nz", bodyL)
}

fun compileIf (labels@[elseL, fiL, env], expr, stmt1, stmt2) {
  compileSMWithBuf (expr) <+
    CJMP ("z", elseL) <+>
    compileSMWithBuf (stmt1) <+
    JMP (fiL) <+
    LABEL (elseL) <+>
    compileSMWithBuf (stmt2) <+
    LABEL (fiL)
}

fun getFunsAndUpdateEnv () {
  case getFuns (stmtCompEnv) of
    [funcs, env] ->
      stmtCompEnv := env;
      funcs
  esac
}

fun compileFuncs () {
  var topEnv = stmtCompEnv;
  var result = case getFunsAndUpdateEnv () of 
                 {} -> emptyBuffer ()
               | funcs ->
                   foldl (
                     fun (buf, f) {
                       case f of 
                         Fun (fLabel, args, body, state) ->                          
                          var insns; 
                          stmtCompEnv := addArgs (beginFun (stmtCompEnv, state), args);
                          insns := compileSMWithBuf (body);
                          buf <+ LABEL (fLabel) 
                              <+ BEGIN (fLabel, size (args), getLocals (stmtCompEnv))
                              <+> insns
                              <+ END
                              <+> compileFuncs ()
                       esac
                     },
                     emptyBuffer (),
                     funcs
                   )
               esac;
  stmtCompEnv := topEnv;
  result
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  var main = compileSMWithBuf (stmt);
  var result = getBuffer (
    singletonBuffer (LABEL ("main"))
      <+ BEGIN ("main", 0, getLocals (stmtCompEnv))
      <+> main
      <+ END
      <+> compileFuncs ()
  );
  -- failure (stmt.string);
  result
}
