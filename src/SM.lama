-- Stack machine.
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

fun evalCJmp(env, [stk, st, w],insns, cond, l ) {
  case case stk of
    0:stk -> case cond of
                 "nz" -> [stk, insns] |
                 "z" -> [stk, fromLabel (env, l)]
                esac |
    _:stk -> case cond of
                 "nz" -> [stk, fromLabel (env, l)] |
                 "z" -> [stk, insns]
               esac
  esac of
    [stk, insns] -> [[stk, st, w], insns]
  esac
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c@[stk, st, w], insns) {
  case insns of
      READ        : rest     -> eval (env, case c of [stk, st, w] -> 
                                              var rw= readWorld(w); 
                                              [rw[0]:stk, st, rw[1]] 
                                              esac, 
                                              rest)
    | WRITE       : rest    -> eval (env, case c of [a:stk, st, w] -> [stk, st, writeWorld(a, w)] esac, rest) 
    | BINOP (op)  : rest    -> eval (env, case stk of b:a:stk  -> [binop (op, a, b):stk, st, w] esac, rest)
    | LD    (x)   : rest    -> eval (env, [st(x):stk, st, w], rest)      
    | ST    (x)   : rest    -> eval (env, case stk of v:tail -> [stk, st <- [x, v], w] esac, rest)
    | CONST (n)   : rest    -> eval (env, [n:c[0], c[1], c[2]], rest) 
    | LABEL (l)   : rest    -> eval (env, c, rest)
    | JMP (l)   : rest      -> eval (env, c, fromLabel (env, l)) 
    | CJMP (cond, l) : rest -> case evalCJmp (env, c, rest, cond, l) of [c, rest] -> eval (env, c, rest)  esac | {} -> c
    | LDA   (x)   : rest    -> eval (env, [Ref(x):stk, st, w], rest)
    | STI         : rest    -> eval (env, case stk of v:Ref(x):tail -> [v:tail, st <- [x, v], w] esac, rest)
    | DROP        : rest    -> eval (env, case stk of n:tail -> [tail, st, w] esac, rest)
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expr into a stack machine code.
-- Takes an expr, returns a list of stack machine instructions
fun compileWhile(env, expr, body) {
  case genLabels (env, 2) of
      [cond, endL, env] -> 
        case compile(env, expr) of
          [env, exprc] ->
            case compile (env, body) of
              [env, bodyc] -> [env, 
                  singletonBuffer (LABEL (cond)) <+> exprc <+ 
                            CJMP ("z", endL) <+> bodyc <+ 
                            JMP (cond) <+ 
                            LABEL (endL)]
            esac
        esac
  esac
}

fun compileDoWhile(env, body, expr) {
  case genLabel (env) of
            [thenL, env] -> 
              case compile(env, body) of
                [env, bodyc] ->
                  case compile (env, expr) of
                    [env, exprc]   -> [env,  singletonBuffer (LABEL (thenL)) <+> bodyc <+> exprc <+  CJMP ("nz", thenL)]
                  esac
              esac
        esac
}

fun compileIf(env, expr, ifT, ifF) {
  case genLabels (env, 3) of
      [ifStmt, thenStart, thenEnd, env] -> 
        case compile (env, expr) of
          [env, exprc] -> 
            case compile(env, ifT) of
              [env, tc] -> 
                case compile(env, ifF) of 
                  [env, fc] -> 
                          [env, exprc <+  CJMP ("z", thenStart) <+  LABEL (ifStmt) <+> tc <+  JMP (thenEnd) <+  LABEL (thenStart) <+> fc  <+ LABEL (thenEnd)]
              esac
          esac  
      esac
  esac 
}

fun compileSeq(env, st1, st2) {
  case compile(env, st1) of
    [env, c1] ->
      case compile (env, st2) of
        [env, c2] -> [env, c1 <+> c2]
      esac
  esac
}

fun compliBinop(env, op, l, r) {
  case compile (env, l) of
    [env, lc] ->
      case compile (env, r) of
        [env, rc] -> [env, lc <+> rc <+ BINOP (op)]
      esac
  esac
}

fun compileAssn(env, v, x) {
  case compile(env, v) of
      [env, lc] ->
          case compile (env, x) of
            [env, rc] -> [env, lc <+> rc <+ STI]
          esac
  esac 
}

fun compile(env, stmt) {
      case stmt of
        Assn (v, x)           -> compileAssn(env, v, x)      
        | Const (n)           -> [env, singletonBuffer (CONST (n))]
        | Var (v)             -> [env, singletonBuffer (LD (v))]
        | Binop (op, l, r)  -> compliBinop(env, op, l, r)
        | Seq (st1, st2)      -> compileSeq(env, st1, st2)
        | Read (x)            -> [env, listBuffer ({READ, ST (x), DROP})]
        | Write (x)           -> case compile (env, x) of [env, c] -> [env, c <+ WRITE] esac
        | If (expr, ifT, ifF) -> compileIf(env, expr, ifT, ifF)
        | While (exp, body)        -> compileWhile(env, exp, body)
        | DoWhile (body, exp)      -> compileDoWhile(env, body, exp)
        | Ref (x)             -> [env, singletonBuffer (LDA (x))]
        | Skip                -> [env, emptyBuffer ()]
        | Ignore (x) -> case compile (env, x) of [env, c] -> [env, c <+ DROP] esac
    esac
  }

public fun compileSM (stmt) {
  getBuffer (compile(initCompEnv (), stmt)[1])
}
