-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;

fun binary_op([b:a:stack, st, w], op){
	var res = case op of
		"+" -> a + b |
		"-" -> a - b |
		"*" -> a * b |
		"/" -> a / b |
		"%" -> a % b |
		"<" -> a < b |
		">" -> a > b |
		"<=" -> a <= b |
		">=" -> a >= b |
		"==" -> a == b |
		"!=" -> a != b |
		"&&" -> a && b |
		"!!" -> a !! b
	esac;
	[res:stack, st, w]
}

fun read_op([stack, st, w]) {
	var res = readWorld(w);
	[res[0]:stack, st, res[1]]
}

fun write_op([s, st, w]) {
	case s of
		a:stack -> [stack, st, writeWorld(a, w)]
		--| a -> [{}, st, writeWorld(a, w)]
	esac
}

fun ld_op(x, [stack, st, w]) {
	[st(x):stack, st, w]
}

fun st_op(x, [a:stack, st, w]) {
	[a:stack, st <- [x, a], w]
}


-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}


fun cjmp_op1 (c, l, env, [s:stack, state, world], insns) {
	case c of 
		"z" -> if s == 0 then  [[stack, state, world], fromLabel(env, l)] 
				else [[stack, state, world], insns] 
				fi |
		"nz" -> if s != 0 then [[stack, state, world], fromLabel(env, l)] 
				else [[stack, state, world], insns]
				fi 
	esac
}

fun eval_help1 (env, c, i) {
	var insns = i;
	var context = c;
	while insns != {} do
		case insns of
		ins1:ins2 ->
			case ins1 of
    			READ      -> context := read_op(context); insns := ins2
  			| WRITE     -> context := write_op(context); insns:= ins2
  			| BINOP (s) -> context := binary_op(context, s); insns := ins2
  			| LD    (x) -> context := ld_op(x, context); insns := ins2   
  			| ST    (x) -> context := st_op(x, context); insns := ins2
  			| CONST (n) -> context := [n:context[0], context[1], context[2]]; insns := ins2
			| JMP   (l) -> insns := fromLabel(env, l)
			| CJMP  (cc, l) -> var out = cjmp_op1(cc, l, env, context, ins2); context := out[0]; insns := out[1]
			| LABEL (l) -> insns := ins2
			| DROP      -> case context[0] of s:state -> context := [state, context[1], context[2]]  esac; insns := ins2
			| LDA   (l) -> context := [l:context[0], context[1], context[2]]; insns := ins2
			| STI       -> case context of [a:b:stack, state, world] -> context := [a:stack, state <- [b, a], world] esac; insns := ins2
  			esac
 		esac
	od;
	context
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
	--printf("%s", insns.string);
	eval_help1(env, c, insns)
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
	case expr of
		Const(a) -> singletonBuffer(CONST(a)) |
		Var(a) -> singletonBuffer(LD(a)) |
		Binop(a, expr1, expr2) -> compileExpr(expr1) <+> compileExpr(expr2) <+> singletonBuffer(BINOP(a)) |	
		_ -> failure("The expression is not recognized!")
	esac
}


fun ifSM(env, expr, stmt1, stmt2) {
	var a0 = compileSMBuffer(expr, env);
	var l1 = genLabel(a0[1]);
	var l2 = genLabel(l1[1]);
	var a3 = compileSMBuffer(stmt1, l2[1]);
	var a4 = compileSMBuffer(stmt2, a3[1]);
	[a0[0] <+ CJMP("z", l1[0]) <+> a3[0] <+ JMP(l2[0]) <+ LABEL(l1[0]) <+> a4[0] <+ LABEL(l2[0]), a4[1]]
}

fun whileSM(env, expr, stmt) {
	var l1 = genLabel(env);
	var a11 = compileSMBuffer(expr, l1[1]);
	var l2 = genLabel(a11[1]);
	var a3 = compileSMBuffer(stmt, l2[1]);
	[singletonBuffer(LABEL(l1[0])) <+> a11[0] <+ CJMP("z", l2[0]) <+> a3[0] <+ JMP(l1[0]) <+ LABEL(l2[0]), a3[1]]
}

fun doWhileSM(env, expr, stmt) {
	var l1 = genLabel(env);
	var a2 = compileSMBuffer(stmt, l1[1]);
	var a3 = compileSMBuffer(expr, a2[1]);
	[singletonBuffer(LABEL(l1[0])) <+> a2[0] <+> a3[0] <+ CJMP("nz", l1[0]), a3[1]]	
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSMBuffer (stmt, env) {
	case stmt of
		Skip -> [emptyBuffer(), env] |
		Assn(a, expr) -> var a1 = compileSMBuffer(a, env), a2 = compileSMBuffer(expr, a1[1]); [a1[0] <+> a2[0] <+ STI, a2[1]] |
		Seq(stmt1, stmt2) -> var a1 = compileSMBuffer(stmt1, env);
				     var a2 = compileSMBuffer(stmt2, a1[1]);
				     [a1[0] <+> a2[0], a2[1]] |
		Read(a) -> case a of Ref(a) -> [singletonBuffer(READ) <+ ST(a) <+ DROP, env] esac |
		Write(expr) -> var a1 = compileSMBuffer(expr, env); [a1[0] <+ WRITE, a1[1]] |
		If(expr, stmt1, stmt2) -> ifSM(env, expr, stmt1, stmt2) |
		While(expr, stmt1) -> whileSM(env, expr, stmt1) |
		DoWhile(stmt1, expr) -> doWhileSM(env, expr, stmt1) | 
		Const(a) -> [singletonBuffer(CONST(a)), env] |
		Var(a) -> [singletonBuffer(LD(a)), env] |
		Binop(a, expr1, expr2) -> var a1 = compileSMBuffer(expr1, env), a2 = compileSMBuffer(expr2, a1[1]); [a1[0] <+> a2[0] <+ BINOP(a), a2[1]] |
		Ref(a) -> [singletonBuffer(LDA(a)), env] |
		Ignore(a) -> var a1 = compileSMBuffer(a, env); [a1[0] <+ DROP, a1[1]] |	
		_ -> failure("The statement is not recognised!")
	esac
}


public fun compileSM (stmt) {
	getBuffer(compileSMBuffer(stmt, initCompEnv())[0])
}
