-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  case insns of
    BINOP (bp):tl -> 
	  fun (y:x:s){
        eval ([ binop(bp, x,y):s, c[1], c[2]], tl)
      }(c[0])
  | CONST (n):tl -> 
      eval([ n:c[0], c[1], c[2]], tl)
  | READ:tl  ->  
      var n;
      n := readWorld (c[2]);
      eval ([n[0]:c[0], c[1], n[1]], tl)
  | WRITE:tl -> 
      fun (z:s){
        eval([s, c[1], writeWorld(z, c[2])], tl)
      }(c[0])
  | LD (x):tl -> 
     eval ([c[1](x):c[0], c[1], c[2]], tl)
  | ST (x):tl -> 
      fun (z:s){
        eval ([ s, c[1] <- [x, z], c[2]], tl)
      }(c[0])
  | 0 -> c
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
 case expr of
    Var   (x)         -> singletonBuffer(LD (x))
  | Const (n)         -> singletonBuffer(CONST (n))
  | Binop (s, e1, e2) -> compileExpr(e1) <+> compileExpr(e2) <+ BINOP (s)
 esac 
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  getBuffer (cmpSM (stmt))
}

fun cmpSM(stmt){
  case stmt of
    Assn  (s, expr) -> compileExpr(expr) <+ ST (s)
  | Read  (x)       -> listBuffer ( {READ, ST (x)} )
  | Write (expr)    -> compileExpr(expr) <+ WRITE
  | Seq   (s1, s2)  -> cmpSM(s1) <+> cmpSM(s2) 
  | Skip            -> emptyBuffer() 
  esac
}
