-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Return pair ot new context and poiner to next command
-- nextCommant = SHORT | LONG (label)
public fun evalCommand (c@[stack, state, world], command) {
  case command of 
    READ -> (
      var tmp = readWorld (world);
      var value = tmp.fst;
      var newWorld = tmp.snd;
      [[value:stack, state, newWorld], SHORT]
  )
  | WRITE -> (
      case stack of 
        value:newStack -> (
          var newWorld = writeWorld (value, world);
          [[newStack, state, newWorld], SHORT]
      )
      | _ -> failure ("Got empty stack to WRITE")
      esac
  )
  | BINOP (opStr) -> (
      case stack of
        snd:fst:rest -> (
          var value = evalOp (opStr, fst, snd);
          [[value:rest, state, world], SHORT]
      )
      | _ -> failure ("Less than 2 elements on stack for BINOP")
      esac
  )
  | LD (varName) -> (
      var varValue = state (varName);
      [[varValue:stack, state, world], SHORT]
  )
  | ST (varName) -> (
    case stack of
      varValue:tail -> (  
        var newState = state <- [varName, varValue];
        [[stack, newState, world], SHORT]
    )
    | _ -> failure ("Got empty stack for ST")
    esac
  )
  | CONST (value) -> [[value:stack, state, world], SHORT]
  | JMP (label) -> [c, LONG (label)]
  | LABEL (_) -> [c, SHORT]
  | CJMP (type, label) -> (
    case stack of
      head:tail -> (
        var nextCommand = if (compare (type, "z") == 0 && head == 0)
                          !! (compare (type, "nz") == 0 && head != 0) then
                            LONG (label)
                          else
                            SHORT
                          fi;
        [[tail, state, world], nextCommand]
    )
    | _ -> failure ("Got empty stack for CJMP")
    esac
  )
  | DROP -> 
    case stack of
      head:tail -> [[tail, state, world], SHORT]
    | _ -> failure ("Got empty stack for DROP")
    esac
  | DUP ->
    case stack of
      head:tail -> [[head:stack, state, world], SHORT]
    | _ -> failure ("Got empty stack for DUP")
    esac
  | LDA (x) -> [[Ref (x):stack, state, world], SHORT]
  | STI -> 
    case stack of
      v:Ref (x):tail -> [[v:tail, state <- [x, v], world  ], SHORT]
    | _ -> failure ("Too small stack for STI")
    esac
  esac
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
  case insns of 
    {} -> c
  | head:tail -> 
    case evalCommand (c, head) of [newC, marker] ->
    case marker of
      SHORT -> eval (env, newC, tail)
    | LONG (label) -> eval (env, newC, fromLabel (env, label))
    esac esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  -- printf ("%s\n", showSM (insns));
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles a statement(expression) into a stack machine code.
-- Takes a statement, returns a buffer
-- of stack machine instructions and enviroment
fun compileSMBuff (env, stmt) {
  case stmt of
    Var (varName) -> [singletonBuffer (LD (varName)), env]
  | Const (c) -> [singletonBuffer (CONST (c)), env]
  | Binop (opStr, l, r) -> 
    case compileSMBuff (env, l) of [codeL, env1] ->
    case compileSMBuff (env1, r) of [codeR, env2] ->
      [codeL <+> codeR <+ BINOP (opStr), env2]
    esac esac
  | Assn (e0, e1) -> 
    case compileSMBuff (env, e0) of [code0, env1] ->
    case compileSMBuff (env1, e1) of [code1, env2] ->
      [code0 <+> code1 <+ STI, env2]
    esac esac
  | Read (e) -> 
    case compileSMBuff (env, e) of [codeE, env1] ->
      [codeE <+ READ <+ STI <+ DROP, env1]
    esac
  | Write (expr) -> case compileSMBuff (env, expr) of
                      [code, env1] -> [code <+ WRITE, env1]
                    esac
  | Skip -> [emptyBuffer (), env]
  | Seq (x, y) -> 
    case compileSMBuff (env, x) of [codeX, env1] ->
    case compileSMBuff (env1, y) of [codeY, env2] ->
      [codeX <+> codeY, env2]
    esac esac
  | If (cond, trueStmt, falseStmt) -> (
    var newLabels = genLabels (env, 2);
    var falseLabel = newLabels[0];
    var exitLabel = newLabels[1];
    var env0 = newLabels[2];
    
    var condRes = compileSMBuff (env0, cond);
    var condCode = condRes.fst; 
    var env1 = condRes.snd;
    
    var trueStmtCompiled = compileSMBuff (env1, trueStmt);
    var trueStmtCode = trueStmtCompiled.fst;
    var env2 = trueStmtCompiled.snd;

    var falseStmtCompiled = compileSMBuff (env2, falseStmt);
    var falseStmtCode = falseStmtCompiled.fst;
    var env3 = falseStmtCompiled.snd;

    var newCode = condCode
                  <+ CJMP ("z", falseLabel) 
                  <+> trueStmtCode
                  <+ JMP (exitLabel)
                  <+ LABEL (falseLabel)
                  <+> falseStmtCode
                  <+ LABEL (exitLabel);
    [newCode, env3]
  )
  | While (cond, body) -> (
    var newLabels = genLabels (env, 2);
    var condLabel = newLabels[0];
    var exitLabel = newLabels[1];
    var env0 = newLabels[2];

    var condRes = compileSMBuff (env0, cond);
    var condCode = condRes.fst;
    var env1 = condRes.snd;

    var bodyCompiled = compileSMBuff (env1, body);
    var bodyCode = bodyCompiled.fst;
    var env2 = bodyCompiled.snd;

    var newCode = singletonBuffer (LABEL (condLabel))
                  <+> condCode
                  <+ CJMP ("z", exitLabel)
                  <+> bodyCode
                  <+ JMP (condLabel)
                  <+ LABEL (exitLabel);
    [newCode, env2]
  )
  | DoWhile (body, cond) -> (
    var newLabel = genLabel (env);
    var bodyLabel = newLabel.fst;
    var env0 = newLabel.snd;

    var condRes = compileSMBuff (env0, cond);
    var condCode = condRes.fst;
    var env1 = condRes.snd;

    var bodyCompiled = compileSMBuff (env1, body);
    var bodyCode = bodyCompiled.fst;
    var env2 = bodyCompiled.snd;
    
    var newCode = singletonBuffer (LABEL (bodyLabel))
                  <+> bodyCode
                  <+> condCode
                  <+ CJMP ("nz", bodyLabel);
    [newCode, env2]
  )
  | Ref (x) -> [singletonBuffer (LDA (x)), env]
  | Ignore (e) -> case compileSMBuff (env, e) of
                    [code, env1] -> [code <+ DROP, env1]
                  esac
  esac
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  getBuffer ((compileSMBuff (initCompEnv (), stmt)).fst)
}
