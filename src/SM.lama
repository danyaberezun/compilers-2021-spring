-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> x
    esac
  }
  
  case i of
    READ             -> "READ"
  | WRITE            -> "WRITE"
  | BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | STI              -> "STI"
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (s)       -> sprintf ("LABEL %s", s)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (c, l)    -> sprintf ("CJMP %s, %s", c, l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, w, insns) {
  -- Global state maps names of global variables to values
  var globalState = ref (fun (x) {error (sprintf ("name ""%s"" is undefined", x), getLoc (x))});
  
  -- Make a fresh local state: a pair of arrays for arguments and local variables;
  -- takes the numbers of arguments and local variables respectively
  fun makeState (a, l) {
    [initArray (a, fun (_) {0}), initArray (l, fun (_) {0})]
  }

  -- Lookups a location in local/global states
  fun lookup ([args, locs], loc) {
    case loc of
      Arg (i) -> args[i]
    | Loc (i) -> locs[i]
    | Glb (x) -> deref (globalState) (x)
    esac 
  }

  -- Assigns a value to a location
  fun assign ([args, locs], loc, v) {
    case loc of
      Arg (i) -> args[i] := v
    | Loc (i) -> locs[i] := v
    | Glb (x) -> var g = deref (globalState);
                 globalState ::= fun (y) {if compare (x, y) == 0 then v else g (y) fi}
    esac
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take (list, n) {
    fun inner (n, acc, list) {
      if n == 0
      then [list, acc]
      else inner (n-1, list.hd : acc, list.tl)
      fi
    }

    inner (n, {}, list)
  }
  
  fun assignRecirsive(state, i, curvalues) {
	case curvalues of 
			{} -> skip
		|	curvalue : othersvalues -> (
				assign(state, Arg (i),  curvalue);
				assignRecirsive(state, i + 1, othersvalues)
			)	
	esac
  }
  
  fun evalOneInsn (c, insn, otherinsn) { 
	var stack = c[0];
	var callstack = c[1];
	var state = c[2];
	var world = c[3];
    case insn of
		READ      -> (
		  var readRes = readWorld(world);
		  var readValue = readRes.fst;
		  var worldNew = readRes.snd; 
		  var stackNew = readValue : stack;
		  [[stackNew, callstack, state, worldNew], otherinsn]
		)
		| WRITE     -> (
		  case stack of
			value : stackNew -> (
			  var worldNew = writeWorld (value, world);
			  [[stackNew, callstack, state, worldNew], otherinsn]
			)
		  esac
		)
		| BINOP (s) -> (
		  case stack of
			y:x:stackNew -> (
			  var binopRes = evalOp (s, x, y);
			  var stackNew2 = binopRes : stackNew;
			  [[stackNew2, callstack, state, world], otherinsn]
			)
		  esac
		)
		| LD    (varName) -> (
		  var varValue = lookup(state, varName);
		  var stackNew = varValue : stack;
		  [[stackNew, callstack, state, world], otherinsn]
		)
		| LDA (varName) -> (
			var stackNew = varName : stack;
			[[stackNew, callstack, state, world], otherinsn]
		)
		| ST    (varName) -> (
		  case stack of
			varValue : stackNew -> (
			  var cNew = [stack, callstack, state, world];
			  assign(state, varName, varValue);
			  [cNew, otherinsn]
			)
		  esac
		)
		| STI -> (
			case stack of 
				value : varname : stackTail -> (
					var stackNew = value:stackTail;
					var cNew = [stackNew, callstack, state, world];
					assign(state, varname, value);
					[cNew, otherinsn]
				)
			esac
		)
		| CONST (n) -> (
		  var stackNew = n : stack;
		  [[stackNew, callstack, state, world], otherinsn]
		)
		| LABEL (label) -> (
		  [[stack, callstack, state, world], otherinsn]
		)
		| JMP (label) -> (
			var cNew = [stack, callstack, state, world];
			var newinsn = fromLabel(env, label);
			[cNew, newinsn]
		)
		| CJMP (cond, label) -> (
			
			case stack of
				value : stackNew -> (
				  var cNew = [stackNew, callstack, state, world];
				  if (value != 0 && compare (cond, NZ) == 0) then 
				   [cNew, fromLabel(env, label)]
				  elif (value == 0 && compare (cond, Z) == 0) then
				   [cNew, fromLabel(env, label)]
				  else
				   [cNew, otherinsn]
				  fi
				)
			esac
		)
		| CALL (funLabel, funArgs) ->  (
			var callstackNew = [state, otherinsn] : callstack;
			var cNew = [stack, callstackNew, state, world];
			var insnNew = fromLabel(env, funLabel);
			[cNew, insnNew]
		)
		| BEGIN (_, argsCnt, localsCnt) -> (
			var res = take(stack, argsCnt);
			var stackNew = res[0];
			var argsValues = res[1];
			var stateNew = makeState(argsCnt, localsCnt);
			var cNew = [stackNew, callstack, stateNew, world];
			assignRecirsive(stateNew, 0, argsValues);
			[cNew, otherinsn]
		)
		| GLOBAL (varName) -> (
			var cNew = [stack, callstack, state, world];
			var locVar = Glb(varName);
			assign (state, locVar, 0);
			[cNew, otherinsn]
		)
		| END -> (
			case callstack of 
					{} -> [c, {}]
				|	[state1, insn1]:callstack1 -> [[stack, callstack1, state1, world], insn1]
			esac
		)
		| DUP -> (
			case stack of
				dupPart:stackTail -> [[dupPart:stack, callstack, state, world], otherinsn]
			esac
		)
		| DROP -> (
			case stack of
				dropped:stackNew -> [[stackNew, callstack,state, world], otherinsn]
			esac
		)
    esac
  }
  -- Core interpreter: takes a configuration and a program, returns a configuration
  (* Assignment *)
  fun eval (c@[st, cst, s, w], insns) {
    case insns of 
		{} -> c
		| insn : other -> (
		  var resEval = evalOneInsn (c, insn, other);
		  var newc = resEval[0];
		  var newOther = resEval[1];
		  eval (newc, newOther)
		)
	esac
  }
  (* End *)
  
  eval ([{}, {}, makeState (0, 0), w], insns) [3].getOutput
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), createWorld (input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [sprintf ("L%d", nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
  }

  -- Adds a new function 
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScope (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScope (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar (name) {
    if scopeDepth == 1
    then makeCompEnv (nLabels, scopeDepth, addName (state, name, Glb (name)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addName (state, name, Loc (nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }
  
  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 1, enterFunction (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [functions, makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, {})]
  }

  -- Lookups a name of a variable
  fun lookupVar (name) {
    case lookup (state, name) of
      Fun (_, _) -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookup (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if scopeDepth == 1
     then [sprintf ("L%s", name),             makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions)]
     else [sprintf ("L%s_%d", name, nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
     fi 
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 1
  }
  
  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel (env) {
  env [0] ()
}

fun rememberFun (env, name, args, body) {
  env [1] (name, args, body)
}

fun beginScope (env) {
  env [2] ()
}

fun endScope (env) {
  env [3] ()
}

fun addArg (env, name) {
  env [4] (name)
}

fun addVar (env, name) {
  env [5] (name)
}

fun beginFun (env, state) {
  env [6] (state)
}

fun getFuns (env) {
  env [7] ()
}

fun lookupVar (env, name) {
  env [8] (name)
}

fun lookupFun (env, name) {
  env [9] (name)
}

fun getLocals (env) {
  env [10] ()
}

fun genFunLabel (env, name) {
  env [11] (name)
}

fun addFun (env, name, fLabel, nargs) {
  env [12] (name, fLabel, nargs)
}

fun isGlobal (env) {
  env [13] ()
}

-- Helper function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case genLabel (env) of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
  foldl (fun (env, name) {addArg (env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars (env, names) {
  foldl (fun (env, name) {addVar (env, name)}, env, names)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.

(* Assignment *)

-- Some guidelines for compiling functions and scopes.
--
-- 1. use env.beginScope/env.endScope properly;
-- 2. in each scope traverse the definitions twice:
--    a. first, add all bindings into symbolic state,
--       using end.addVar/env.addFun;
--    b. do not forget to generate GLOBAL instructions for
--       top-level variable declarations;
--    c. on the secord traversal add functions themselves for
--       future code generation (use env.rememberFun).
-- 3. the overall flow for codegeneration:
--    a. generate the code for thetopmost expression (the progrman itself);
--    b. take list of nested functions definitions via env.getFuns and
--       generate the code for each function;
--    c. repeat b. until no function definitions appear.
-- 4. when compiling functions, do not forget to create proper
--    environment (use env.beginFun) and register arguments
--    (use env.addArg).

fun compileArgsRec (env, exprs) {
	case exprs of 
			{} -> [env, emptyBuffer()]
		|	expr:othersexp -> (
			var res1 = compileSMBuff (env, expr);
			case res1 of
				[env1, buff1] -> (
					var res2 = compileArgsRec (env1, othersexp);
					var env2 = res2[0];
					var buff2 = res2 [1];
					[env2, buff1 <+> buff2] 
				)
			esac
			)
	esac
}

fun collectDefenitions (definitions){
	foldl (
		fun ([vars, funs], def) {
			case def of 
				Var (names) -> (
					var listres1 = listBuffer (names);	
					[listres1 <+> vars, funs] 
				)
				|	curFun@Fun(label, args, body) -> [vars, curFun:funs] 
			esac
		},
		[emptyBuffer(), {}],
		definitions
	)
}


fun addFuns (env, funs) {
	foldl (
		fun ([env1, funs1], Fun(name, args, body)) {
			var res = genFunLabel(env1, name); 
			case res of 
				[label, env2] -> (
					var env3 = addFun(env2, name, label, size(args));
					var newFuns = FunLabel (label, args, body) : funs1;
					[env3, newFuns] 
				)
			esac
			
		},
		[env, {}],
		funs
	)
}


fun compileDefinitions(env, definitions) {
	var collectRes = collectDefenitions (definitions);
	var vars = getBuffer (collectRes[0]);
	var funs = collectRes[1];
	var env1 = addVars(env, vars);
	var addFunRes = addFuns (env1, funs);
	case addFunRes of 
		[envNew, addedFuns] -> (
			if (isGlobal(envNew))
				then [envNew, listBuffer(map(fun(varName) {GLOBAL(varName)}, vars)), addedFuns]
				else [envNew, emptyBuffer (), addedFuns]
			fi
		)
	esac
}

fun rememberFunsRec(env, funs) {
	case funs of 
			{} -> env
		|	f : otherFuns -> (
			case f of 
				FunLabel(funLabel, funArgs, funBody) -> (
					rememberFunsRec (rememberFun(env, funLabel, funArgs, funBody), otherFuns)
				)
			esac
		)
	esac
	
}


fun compileSMBuff (env, stmt) {
	case stmt of
		Assn (varName, expr) -> (
			case compileSMBuff(env, varName) of 
				[env1, varBuff] -> 
					case compileSMBuff(env1, expr) of 
						[env2, exprBuff] -> [env2, varBuff <+> exprBuff <+ STI]
					esac
			esac
	   )
    |  Seq (stmt1, stmt2) -> ( 
       var res1 = compileSMBuff (env, stmt1);
       case res1 of
         [env1, buff1] -> (
           var res2 = compileSMBuff (env1, stmt2);
           var env2 = res2[0];
           var buff2 = res2 [1];
           [env2, buff1 <+> buff2] 
         )
       esac
    )
    |  Skip -> [env, emptyBuffer ()]
    |  Read (varName) -> (
		case compileSMBuff (env, varName) of 
			[env1, varBuff] -> [env1, varBuff <+ READ <+ STI <+ DROP]
		esac
	)
    |  Write (expr) -> case compileSMBuff (env, expr) of 
			[env1, exprBuff] -> [env1, exprBuff <+ WRITE]
		esac
    |  If  (ifCond, thenExpr, elseExpr) -> (
         var newLabels = genLabels (env, 2);
         case newLabels of
           [elseLabel, endLabel, env0] -> (
             var condComp = compileSMBuff (env0, ifCond);
			 var env1 = condComp[0];
             var condBuff = condComp[1];
    
             var thenComp = compileSMBuff (env1, thenExpr);
             var env2 = thenComp[0];
             var thenBuff = thenComp[1];

             var elseComp = compileSMBuff (env2, elseExpr);
             var env3 = elseComp[0];
             var elseBuff = elseComp[1];

             var newCode = condBuff
                        <+ CJMP (Z, elseLabel) 
                        <+> thenBuff
                        <+ JMP (endLabel)
                        <+ LABEL (elseLabel)
                        <+> elseBuff
                        <+ LABEL (endLabel);
             [env3, newCode]
           )
         esac
    )
    |  While (whileCond, whileExpr) -> (
        var newLabels = genLabels (env, 2);
		case newLabels of
			[condLabel, endLabel, env0] -> (
				var condComp = compileSMBuff (env0, whileCond);
				var env1 = condComp[0];
				var condBuff = condComp[1];
				

				var exprRes = compileSMBuff (env1, whileExpr);
				var env2 = exprRes[0];
				var exprBuff = exprRes[1];

				var newCode = singletonBuffer (LABEL (condLabel))
							  <+> condBuff
							  <+ CJMP (Z, endLabel)
							  <+> exprBuff
							  <+ JMP (condLabel)
							  <+ LABEL (endLabel);
				[env2, newCode]
			)
		esac
    )
    |  DoWhile (whileExpr, whileCond) -> (
         var newLabel = genLabel (env);
         case newLabel of
           [whileLabel, env0] -> (
             var condComp = compileSMBuff (env0, whileCond);
			 var env1 = condComp[0];
             var condBuff = condComp[1];
			 
             var exprRes = compileSMBuff (env1, whileExpr);
             var env2 = exprRes[0];
             var exprBuff = exprRes[1];
    
             var newCode = singletonBuffer (LABEL (whileLabel))
                        <+> exprBuff
                        <+> condBuff
                        <+ CJMP (NZ, whileLabel);
             [env2, newCode]
          )
        esac
    )
	|  Ref (x) -> (
			var varLoc = lookupVar (env, x);
			[env, singletonBuffer(LDA(varLoc))]
		)
	|  Ignore (expr) -> (
		var exprRes = compileSMBuff(env, expr);
		var env2 = exprRes[0];
        var exprBuff = exprRes[1];
		[env2, exprBuff <+ DROP]
	)
	| Var (varName) -> (
		var varLoc = lookupVar (env, varName);
		[env, singletonBuffer (LD (varLoc))]
	)
	| Const (c) -> [env, singletonBuffer (CONST (c))]
	| Binop (opStr, x, y) -> (
		var xRes = compileSMBuff (env, x);
		var env1 = xRes[0];
		var xBuff = xRes[1];
		
		var yRes = compileSMBuff (env1, y);
		var env2 = yRes[0];
		var yBuff = yRes[1];
		
		[env2, (xBuff <+> yBuff) <+ (BINOP (opStr))]
	)
	| Scope (definitions, expr) ->
		var env1 = beginScope(env);
		var defsRes = compileDefinitions (env1, definitions);
		case defsRes of 
			[env2, globCode, labelFuns] -> (
				var env3 = rememberFunsRec(env2, labelFuns);
				var compRes = compileSMBuff(env3, expr);
				case compRes of 
					[env4, expCode] -> (
						var env5 = endScope(env4);
						[env5, globCode <+> expCode]
					)
				esac
			)
		esac
      
		| Call (funName, args)  -> (
			case lookupFun (env, funName) of 
				Fun (funLabel, argsCnt)  -> (
					var argRecRes = compileArgsRec  (env, args);
					case argRecRes of 
						[envNew, argCode]  -> (
							var resCode = argCode <+  CALL (funLabel, argsCnt);
							[envNew, resCode]
						)
					esac
					
				)
				
			esac
		)
  esac
}


fun compileFunctions (env, funs, curRes) {
	case funs of
			{} -> [env, curRes]
		|	curFun : otherFuns -> (
			case curFun of 
				Fun (funLabel, funArgs, funBody, state) -> (
					var env1 = beginFun (env, state);
					var env2 = addArgs (env1, funArgs);
					var resBody = compileSMBuff (env2, funBody);
					case resBody of
						[env3, bodyBuff] -> (
							var locals = getLocals(env3);
							var argCnt = size (funArgs);
							var funCode = 
								singletonBuffer (LABEL (funLabel)) <+
								BEGIN (funLabel, argCnt, locals) <+>
								bodyBuff <+
								END; 
							compileFunctions (env3, otherFuns, curRes <+> funCode)
						)
					esac
				)
			esac
			
		)
	esac
}


fun compAllFunctions (funs, env) {
	case funs of 
			{} -> emptyBuffer()
		|	_ -> (
			var curCompileRes = compileFunctions (env, funs);
			var genRes = getFuns(curCompileRes[0]);
			curCompileRes[1] <+> compAllFunctions(genRes[0], genRes[1])
		)
	esac
}



public fun compileSM (expr) {
  var mainBuff = compileSMBuff (initCompEnv (), expr);
  case mainBuff of
	[env1, mainCode] -> (
		var locals = getLocals(env1);
		var getFunsRes = getFuns (env1);
		var funCodes = compAllFunctions(getFunsRes[0], getFunsRes[1]);
		getBuffer (
			singletonBuffer (LABEL ("main")) <+
			BEGIN ("main", 0, locals) <+>
			mainCode <+
            END <+>
            funCodes
		)
	)
  esac
}
(* End *)