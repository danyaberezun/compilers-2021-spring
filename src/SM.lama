-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
  case insns of
    {} -> c
  | x:xs -> 
      case x of 
        JMP   (x)       -> eval (env, c, fromLabel (env, x))
      | CJMP  (cond, x) -> evalCJmp (env, c, xs, cond, x)
      | LABEL (x)       -> eval (env, c, xs)
      | _               -> eval (env, evalInsn (c, x), xs)
      esac
  esac
}

fun evalCJmp (env, c, xs, cond, x) {
  var s = pop (c);
  case [cond, s[0]] of
    ["z", 0]  -> eval (env, s[1], fromLabel (env, x))
  | ["nz", 1] -> eval (env, s[1], fromLabel (env, x))
  | _         -> eval (env, s[1], xs)
  esac
}

fun evalInsn (c@[s, st, w], insn) {
  case insn of
    READ       -> read (c)
  | WRITE      -> write (c)
  | BINOP (op) -> binop (op, c)
  | LD    (x)  -> push (st (x), c)
  | LDA   (x)  -> [x:s, st, w]
  | ST    (x)  -> popAndAssign (x, c)
  | STI        -> sti (c)
  | CONST (n)  -> push (n, c)
  | DROP       -> pop (c)[1]
  | DUP        -> push (s[0], c)
  esac
}

fun binop (op, c) {
  var y = pop (c);
  var x = pop (y[1]);
  push (evalOp (op, x[0], y[0]), x[1])
}

fun read (c@[s, st, w]) {
  var r = readWorld (w);
  [r[0]:s, st, r[1]]
}

fun write (c@[s, st, w]) {
  var x = pop (c);
  [x[1][0], st, writeWorld (x[0], w)]
}

fun pop ([n:s, st, w]) {
  [n, [s, st, w]]
}

fun popAndAssign (x, [n:s, st, w]) {
  [s, st <- [x, n], w]
}

fun push (n, c@[s, st, w]) {
  [n:s, st, w]
}

fun sti ([n:x:s, st, w]) {
  [n:s, st <- [x, n], w]
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

var stmtCompEnv = initCompEnv ();

fun genLabelsAndUpdateEnv (n) {
  var labels = genLabels (stmtCompEnv, n);
  stmtCompEnv := labels[n];
  labels
}

fun compileSMWithBuf (stmt) {
  case stmt of
    Assn    (x, expr)            -> compileSMWithBuf (x) <+> compileSMWithBuf (expr) <+ STI
  | Seq     (stmt1, stmt2)       -> compileSMWithBuf (stmt1) <+> compileSMWithBuf (stmt2)
  | Skip                         -> emptyBuffer ()
  | Read    (x)                  -> listBuffer ({READ, ST (x)})
  | Write   (expr)               -> compileSMWithBuf (expr) <+ WRITE
  | If      (expr, stmt1, stmt2) -> compileIf (genLabelsAndUpdateEnv (2), expr, stmt1, stmt2)
  | While   (expr, stmt1)        -> compileWhile (genLabelsAndUpdateEnv (2), expr, stmt1)
  | DoWhile (stmt1, expr)        -> compileDoWhile (genLabelsAndUpdateEnv (1), stmt1, expr)
  | Var     (x)                  -> singletonBuffer (LD (x))
  | Ref     (x)                  -> singletonBuffer (LDA (x))
  | Const   (i)                  -> singletonBuffer (CONST (i))
  | Binop   (op, expr1, expr2)   -> compileSMWithBuf (expr1) <+> compileSMWithBuf (expr2) <+ BINOP (op)
  | Ignore  (expr)               -> compileSMWithBuf (expr) <+ DROP
  esac
}

fun compileWhile (labels@[startL, bodyL, env], expr, stmt) {
  singletonBuffer (JMP (startL)) <+ 
    LABEL (bodyL) <+>
    compileSMWithBuf (stmt) <+ 
    LABEL (startL) <+> 
    compileSMWithBuf (expr) <+
    CJMP ("nz", bodyL)
}

fun compileDoWhile (labels@[bodyL, env], stmt, expr) {
  singletonBuffer (LABEL (bodyL)) <+>
    compileSMWithBuf (stmt) <+> 
    compileSMWithBuf (expr) <+
    CJMP ("nz", bodyL)
}

fun compileIf (labels@[elseL, fiL, env], expr, stmt1, stmt2) {
  compileSMWithBuf (expr) <+
    CJMP ("z", elseL) <+> 
    compileSMWithBuf (stmt1) <+
    JMP (fiL) <+
    LABEL (elseL) <+>
    compileSMWithBuf (stmt2) <+
    LABEL (fiL)
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  getBuffer (compileSMWithBuf (stmt))
}
